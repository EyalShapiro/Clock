/*
  @license
	Rollup.js v4.6.1
	Thu, 30 Nov 2023 05:22:35 GMT - commit ded37aa8f95d5ba9786fa8903ef3424fd0549c73

	https://github.com/rollup/rollup

	Released under the MIT License.
*/
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var rollup = require('./rollup.js');

var require$$0$1 = require('fs');

var require$$2 = require('util');

var require$$1 = require('stream');

var require$$0$2 = require('path');

var require$$2$1 = require('os');

var fseventsImporter = require('./fsevents-importer.js');

var require$$0$3 = require('events');

var chokidar = {};
var fs$3 = require$$0$1;
var Readable = require$$1.Readable;
var sysPath$3 = require$$0$2;
var promisify$3 = require$$2.promisify;
var picomatch$1 = rollup.picomatch;
var readdir$1 = promisify$3(fs$3.readdir);
var stat$3 = promisify$3(fs$3.stat);
var lstat$2 = promisify$3(fs$3.lstat);
var realpath$1 = promisify$3(fs$3.realpath);
/**
 * @typedef {Object} EntryInfo
 * @property {String} path
 * @property {String} fullPath
 * @property {fs.Stats=} stats
 * @property {fs.Dirent=} dirent
 * @property {String} basename
 */

var BANG$2 = '!';
var RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';
var NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);
var FILE_TYPE = 'files';
var DIR_TYPE = 'directories';
var FILE_DIR_TYPE = 'files_directories';
var EVERYTHING_TYPE = 'all';
var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];

var isNormalFlowError = function isNormalFlowError(error) {
  return NORMAL_FLOW_ERRORS.has(error.code);
};

var _process$versions$nod = process.versions.node.split('.').slice(0, 2).map(function (n) {
  return Number.parseInt(n, 10);
}),
    _process$versions$nod2 = _slicedToArray(_process$versions$nod, 2),
    maj = _process$versions$nod2[0],
    min = _process$versions$nod2[1];

var wantBigintFsStats = process.platform === 'win32' && (maj > 10 || maj === 10 && min >= 5);

var normalizeFilter = function normalizeFilter(filter) {
  if (filter === undefined) return;
  if (typeof filter === 'function') return filter;

  if (typeof filter === 'string') {
    var glob = picomatch$1(filter.trim());
    return function (entry) {
      return glob(entry.basename);
    };
  }

  if (Array.isArray(filter)) {
    var positive = [];
    var negative = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = filter[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var item = _step.value;
        var trimmed = item.trim();

        if (trimmed.charAt(0) === BANG$2) {
          negative.push(picomatch$1(trimmed.slice(1)));
        } else {
          positive.push(picomatch$1(trimmed));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (negative.length > 0) {
      if (positive.length > 0) {
        return function (entry) {
          return positive.some(function (f) {
            return f(entry.basename);
          }) && !negative.some(function (f) {
            return f(entry.basename);
          });
        };
      }

      return function (entry) {
        return !negative.some(function (f) {
          return f(entry.basename);
        });
      };
    }

    return function (entry) {
      return positive.some(function (f) {
        return f(entry.basename);
      });
    };
  }
};

var ReaddirpStream =
/*#__PURE__*/
function (_Readable) {
  _inherits(ReaddirpStream, _Readable);

  _createClass(ReaddirpStream, null, [{
    key: "defaultOptions",
    get: function get() {
      return {
        root: '.',

        /* eslint-disable no-unused-vars */
        fileFilter: function fileFilter(path) {
          return true;
        },
        directoryFilter: function directoryFilter(path) {
          return true;
        },

        /* eslint-enable no-unused-vars */
        type: FILE_TYPE,
        lstat: false,
        depth: 2147483648,
        alwaysStat: false
      };
    }
  }]);

  function ReaddirpStream() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ReaddirpStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReaddirpStream).call(this, {
      objectMode: true,
      autoDestroy: true,
      highWaterMark: options.highWaterMark || 4096
    }));

    var opts = _objectSpread({}, ReaddirpStream.defaultOptions, {}, options);

    var root = opts.root,
        type = opts.type;
    _this._fileFilter = normalizeFilter(opts.fileFilter);
    _this._directoryFilter = normalizeFilter(opts.directoryFilter);
    var statMethod = opts.lstat ? lstat$2 : stat$3; // Use bigint stats if it's windows and stat() supports options (node 10+).

    if (wantBigintFsStats) {
      _this._stat = function (path) {
        return statMethod(path, {
          bigint: true
        });
      };
    } else {
      _this._stat = statMethod;
    }

    _this._maxDepth = opts.depth;
    _this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    _this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    _this._wantsEverything = type === EVERYTHING_TYPE;
    _this._root = sysPath$3.resolve(root);
    _this._isDirent = 'Dirent' in fs$3 && !opts.alwaysStat;
    _this._statsProp = _this._isDirent ? 'dirent' : 'stats';
    _this._rdOptions = {
      encoding: 'utf8',
      withFileTypes: _this._isDirent
    }; // Launch stream with one parent, the root dir.

    _this.parents = [_this._exploreDir(root, 1)];
    _this.reading = false;
    _this.parent = undefined;
    return _this;
  }

  _createClass(ReaddirpStream, [{
    key: "_read",
    value: function _read(batch) {
      var _this2 = this;

      var _loop2, _ret;

      return regeneratorRuntime.async(function _read$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!this.reading) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return");

            case 2:
              this.reading = true;
              _context2.prev = 3;

              _loop2 = function _loop2() {
                var _ref, path, depth, _ref$files, files, slice, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, entry, entryType, parent;

                return regeneratorRuntime.async(function _loop2$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _ref = _this2.parent || {}, path = _ref.path, depth = _ref.depth, _ref$files = _ref.files, files = _ref$files === void 0 ? [] : _ref$files;

                        if (!(files.length > 0)) {
                          _context.next = 38;
                          break;
                        }

                        slice = files.splice(0, batch).map(function (dirent) {
                          return _this2._formatEntry(dirent, path);
                        });
                        _iteratorNormalCompletion2 = true;
                        _didIteratorError2 = false;
                        _iteratorError2 = undefined;
                        _context.prev = 6;
                        _context.next = 9;
                        return regeneratorRuntime.awrap(Promise.all(slice));

                      case 9:
                        _context.t0 = Symbol.iterator;
                        _iterator2 = _context.sent[_context.t0]();

                      case 11:
                        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                          _context.next = 22;
                          break;
                        }

                        entry = _step2.value;

                        if (!_this2.destroyed) {
                          _context.next = 15;
                          break;
                        }

                        return _context.abrupt("return", {
                          v: void 0
                        });

                      case 15:
                        _context.next = 17;
                        return regeneratorRuntime.awrap(_this2._getEntryType(entry));

                      case 17:
                        entryType = _context.sent;

                        if (entryType === 'directory' && _this2._directoryFilter(entry)) {
                          if (depth <= _this2._maxDepth) {
                            _this2.parents.push(_this2._exploreDir(entry.fullPath, depth + 1));
                          }

                          if (_this2._wantsDir) {
                            _this2.push(entry);

                            batch--;
                          }
                        } else if ((entryType === 'file' || _this2._includeAsFile(entry)) && _this2._fileFilter(entry)) {
                          if (_this2._wantsFile) {
                            _this2.push(entry);

                            batch--;
                          }
                        }

                      case 19:
                        _iteratorNormalCompletion2 = true;
                        _context.next = 11;
                        break;

                      case 22:
                        _context.next = 28;
                        break;

                      case 24:
                        _context.prev = 24;
                        _context.t1 = _context["catch"](6);
                        _didIteratorError2 = true;
                        _iteratorError2 = _context.t1;

                      case 28:
                        _context.prev = 28;
                        _context.prev = 29;

                        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                          _iterator2["return"]();
                        }

                      case 31:
                        _context.prev = 31;

                        if (!_didIteratorError2) {
                          _context.next = 34;
                          break;
                        }

                        throw _iteratorError2;

                      case 34:
                        return _context.finish(31);

                      case 35:
                        return _context.finish(28);

                      case 36:
                        _context.next = 47;
                        break;

                      case 38:
                        parent = _this2.parents.pop();

                        if (parent) {
                          _context.next = 42;
                          break;
                        }

                        _this2.push(null);

                        return _context.abrupt("return", "break");

                      case 42:
                        _context.next = 44;
                        return regeneratorRuntime.awrap(parent);

                      case 44:
                        _this2.parent = _context.sent;

                        if (!_this2.destroyed) {
                          _context.next = 47;
                          break;
                        }

                        return _context.abrupt("return", {
                          v: void 0
                        });

                      case 47:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, null, null, [[6, 24, 28, 36], [29,, 31, 35]]);
              };

            case 5:
              if (!(!this.destroyed && batch > 0)) {
                _context2.next = 17;
                break;
              }

              _context2.next = 8;
              return regeneratorRuntime.awrap(_loop2());

            case 8:
              _ret = _context2.sent;
              _context2.t0 = _ret;
              _context2.next = _context2.t0 === "break" ? 12 : 13;
              break;

            case 12:
              return _context2.abrupt("break", 17);

            case 13:
              if (!(_typeof(_ret) === "object")) {
                _context2.next = 15;
                break;
              }

              return _context2.abrupt("return", _ret.v);

            case 15:
              _context2.next = 5;
              break;

            case 17:
              _context2.next = 22;
              break;

            case 19:
              _context2.prev = 19;
              _context2.t1 = _context2["catch"](3);
              this.destroy(_context2.t1);

            case 22:
              _context2.prev = 22;
              this.reading = false;
              return _context2.finish(22);

            case 25:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[3, 19, 22, 25]]);
    }
  }, {
    key: "_exploreDir",
    value: function _exploreDir(path, depth) {
      var files;
      return regeneratorRuntime.async(function _exploreDir$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return regeneratorRuntime.awrap(readdir$1(path, this._rdOptions));

            case 3:
              files = _context3.sent;
              _context3.next = 9;
              break;

            case 6:
              _context3.prev = 6;
              _context3.t0 = _context3["catch"](0);

              this._onError(_context3.t0);

            case 9:
              return _context3.abrupt("return", {
                files: files,
                depth: depth,
                path: path
              });

            case 10:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this, [[0, 6]]);
    }
  }, {
    key: "_formatEntry",
    value: function _formatEntry(dirent, path) {
      var entry, basename, fullPath;
      return regeneratorRuntime.async(function _formatEntry$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              basename = this._isDirent ? dirent.name : dirent;
              fullPath = sysPath$3.resolve(sysPath$3.join(path, basename));
              entry = {
                path: sysPath$3.relative(this._root, fullPath),
                fullPath: fullPath,
                basename: basename
              };

              if (!this._isDirent) {
                _context4.next = 8;
                break;
              }

              _context4.t0 = dirent;
              _context4.next = 11;
              break;

            case 8:
              _context4.next = 10;
              return regeneratorRuntime.awrap(this._stat(fullPath));

            case 10:
              _context4.t0 = _context4.sent;

            case 11:
              entry[this._statsProp] = _context4.t0;
              _context4.next = 17;
              break;

            case 14:
              _context4.prev = 14;
              _context4.t1 = _context4["catch"](0);

              this._onError(_context4.t1);

            case 17:
              return _context4.abrupt("return", entry);

            case 18:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this, [[0, 14]]);
    }
  }, {
    key: "_onError",
    value: function _onError(err) {
      if (isNormalFlowError(err) && !this.destroyed) {
        this.emit('warn', err);
      } else {
        this.destroy(err);
      }
    }
  }, {
    key: "_getEntryType",
    value: function _getEntryType(entry) {
      var stats, full, entryRealPath, entryRealPathStats, len, recursiveError;
      return regeneratorRuntime.async(function _getEntryType$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              // entry may be undefined, because a warning or an error were emitted
              // and the statsProp is undefined
              stats = entry && entry[this._statsProp];

              if (stats) {
                _context5.next = 3;
                break;
              }

              return _context5.abrupt("return");

            case 3:
              if (!stats.isFile()) {
                _context5.next = 5;
                break;
              }

              return _context5.abrupt("return", 'file');

            case 5:
              if (!stats.isDirectory()) {
                _context5.next = 7;
                break;
              }

              return _context5.abrupt("return", 'directory');

            case 7:
              if (!(stats && stats.isSymbolicLink())) {
                _context5.next = 30;
                break;
              }

              full = entry.fullPath;
              _context5.prev = 9;
              _context5.next = 12;
              return regeneratorRuntime.awrap(realpath$1(full));

            case 12:
              entryRealPath = _context5.sent;
              _context5.next = 15;
              return regeneratorRuntime.awrap(lstat$2(entryRealPath));

            case 15:
              entryRealPathStats = _context5.sent;

              if (!entryRealPathStats.isFile()) {
                _context5.next = 18;
                break;
              }

              return _context5.abrupt("return", 'file');

            case 18:
              if (!entryRealPathStats.isDirectory()) {
                _context5.next = 25;
                break;
              }

              len = entryRealPath.length;

              if (!(full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep)) {
                _context5.next = 24;
                break;
              }

              recursiveError = new Error("Circular symlink detected: \"".concat(full, "\" points to \"").concat(entryRealPath, "\""));
              recursiveError.code = RECURSIVE_ERROR_CODE;
              return _context5.abrupt("return", this._onError(recursiveError));

            case 24:
              return _context5.abrupt("return", 'directory');

            case 25:
              _context5.next = 30;
              break;

            case 27:
              _context5.prev = 27;
              _context5.t0 = _context5["catch"](9);

              this._onError(_context5.t0);

            case 30:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this, [[9, 27]]);
    }
  }, {
    key: "_includeAsFile",
    value: function _includeAsFile(entry) {
      var stats = entry && entry[this._statsProp];
      return stats && this._wantsEverything && !stats.isDirectory();
    }
  }]);

  return ReaddirpStream;
}(Readable);
/**
 * @typedef {Object} ReaddirpArguments
 * @property {Function=} fileFilter
 * @property {Function=} directoryFilter
 * @property {String=} type
 * @property {Number=} depth
 * @property {String=} root
 * @property {Boolean=} lstat
 * @property {Boolean=} bigint
 */

/**
 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
 * @param {String} root Root directory
 * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth
 */


var readdirp$1 = function readdirp$1(root) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var type = options.entryType || options.type;
  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility

  if (type) options.type = type;

  if (!root) {
    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');
  } else if (typeof root !== 'string') {
    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');
  } else if (type && !ALL_TYPES.includes(type)) {
    throw new Error("readdirp: Invalid type passed. Use one of ".concat(ALL_TYPES.join(', ')));
  }

  options.root = root;
  return new ReaddirpStream(options);
};

var readdirpPromise = function readdirpPromise(root) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new Promise(function (resolve, reject) {
    var files = [];
    readdirp$1(root, options).on('data', function (entry) {
      return files.push(entry);
    }).on('end', function () {
      return resolve(files);
    }).on('error', function (error) {
      return reject(error);
    });
  });
};

readdirp$1.promise = readdirpPromise;
readdirp$1.ReaddirpStream = ReaddirpStream;
readdirp$1["default"] = readdirp$1;
var readdirp_1 = readdirp$1;
var anymatch$2 = {
  exports: {}
};
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */

var normalizePath$2 = function normalizePath$2(path, stripTrailing) {
  if (typeof path !== 'string') {
    throw new TypeError('expected path to be a string');
  }

  if (path === '\\' || path === '/') return '/';
  var len = path.length;
  if (len <= 1) return path; // ensure that win32 namespaces has two leading slashes, so that the path is
  // handled properly by the win32 version of path.parse() after being normalized
  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces

  var prefix = '';

  if (len > 4 && path[3] === '\\') {
    var ch = path[2];

    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
      path = path.slice(2);
      prefix = '//';
    }
  }

  var segs = path.split(/[/\\]+/);

  if (stripTrailing !== false && segs[segs.length - 1] === '') {
    segs.pop();
  }

  return prefix + segs.join('/');
};

var anymatch_1 = anymatch$2.exports;
Object.defineProperty(anymatch_1, "__esModule", {
  value: true
});
var picomatch = rollup.picomatch;
var normalizePath$1 = normalizePath$2;
/**
 * @typedef {(testString: string) => boolean} AnymatchFn
 * @typedef {string|RegExp|AnymatchFn} AnymatchPattern
 * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher
 */

var BANG$1 = '!';
var DEFAULT_OPTIONS = {
  returnIndex: false
};

var arrify$1 = function arrify$1(item) {
  return Array.isArray(item) ? item : [item];
};
/**
 * @param {AnymatchPattern} matcher
 * @param {object} options
 * @returns {AnymatchFn}
 */


var createPattern = function createPattern(matcher, options) {
  if (typeof matcher === 'function') {
    return matcher;
  }

  if (typeof matcher === 'string') {
    var glob = picomatch(matcher, options);
    return function (string) {
      return matcher === string || glob(string);
    };
  }

  if (matcher instanceof RegExp) {
    return function (string) {
      return matcher.test(string);
    };
  }

  return function (string) {
    return false;
  };
};
/**
 * @param {Array<Function>} patterns
 * @param {Array<Function>} negPatterns
 * @param {String|Array} args
 * @param {Boolean} returnIndex
 * @returns {boolean|number}
 */


var matchPatterns = function matchPatterns(patterns, negPatterns, args, returnIndex) {
  var isList = Array.isArray(args);

  var _path = isList ? args[0] : args;

  if (!isList && typeof _path !== 'string') {
    throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));
  }

  var path = normalizePath$1(_path, false);

  for (var index = 0; index < negPatterns.length; index++) {
    var nglob = negPatterns[index];

    if (nglob(path)) {
      return returnIndex ? -1 : false;
    }
  }

  var applied = isList && [path].concat(args.slice(1));

  for (var _index = 0; _index < patterns.length; _index++) {
    var pattern = patterns[_index];

    if (isList ? pattern.apply(void 0, _toConsumableArray(applied)) : pattern(path)) {
      return returnIndex ? _index : true;
    }
  }

  return returnIndex ? -1 : false;
};
/**
 * @param {AnymatchMatcher} matchers
 * @param {Array|string} testString
 * @param {object} options
 * @returns {boolean|number|Function}
 */


var anymatch$1 = function anymatch$1(matchers, testString) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;

  if (matchers == null) {
    throw new TypeError('anymatch: specify first argument');
  }

  var opts = typeof options === 'boolean' ? {
    returnIndex: options
  } : options;
  var returnIndex = opts.returnIndex || false; // Early cache for matchers.

  var mtchers = arrify$1(matchers);
  var negatedGlobs = mtchers.filter(function (item) {
    return typeof item === 'string' && item.charAt(0) === BANG$1;
  }).map(function (item) {
    return item.slice(1);
  }).map(function (item) {
    return picomatch(item, opts);
  });
  var patterns = mtchers.filter(function (item) {
    return typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG$1;
  }).map(function (matcher) {
    return createPattern(matcher, opts);
  });

  if (testString == null) {
    return function (testString) {
      var ri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var returnIndex = typeof ri === 'boolean' ? ri : false;
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    };
  }

  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
};

anymatch$1["default"] = anymatch$1;
anymatch$2.exports = anymatch$1;
var anymatchExports = anymatch$2.exports;
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

var isExtglob$1 = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;

  while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */


var isExtglob = isExtglob$1;
var chars = {
  '{': '}',
  '(': ')',
  '[': ']'
};

var strictCheck = function strictCheck(str) {
  if (str[0] === '!') {
    return true;
  }

  var index = 0;
  var pipeIndex = -2;
  var closeSquareIndex = -2;
  var closeCurlyIndex = -2;
  var closeParenIndex = -2;
  var backSlashIndex = -2;

  while (index < str.length) {
    if (str[index] === '*') {
      return true;
    }

    if (str[index + 1] === '?' && /[\].+)]/.test(str[index])) {
      return true;
    }

    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {
      if (closeSquareIndex < index) {
        closeSquareIndex = str.indexOf(']', index);
      }

      if (closeSquareIndex > index) {
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }

        backSlashIndex = str.indexOf('\\', index);

        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
      }
    }

    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {
      closeCurlyIndex = str.indexOf('}', index);

      if (closeCurlyIndex > index) {
        backSlashIndex = str.indexOf('\\', index);

        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
          return true;
        }
      }
    }

    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {
      closeParenIndex = str.indexOf(')', index);

      if (closeParenIndex > index) {
        backSlashIndex = str.indexOf('\\', index);

        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
          return true;
        }
      }
    }

    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {
      if (pipeIndex < index) {
        pipeIndex = str.indexOf('|', index);
      }

      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {
        closeParenIndex = str.indexOf(')', pipeIndex);

        if (closeParenIndex > pipeIndex) {
          backSlashIndex = str.indexOf('\\', pipeIndex);

          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
    }

    if (str[index] === '\\') {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];

      if (close) {
        var n = str.indexOf(close, index);

        if (n !== -1) {
          index = n + 1;
        }
      }

      if (str[index] === '!') {
        return true;
      }
    } else {
      index++;
    }
  }

  return false;
};

var relaxedCheck = function relaxedCheck(str) {
  if (str[0] === '!') {
    return true;
  }

  var index = 0;

  while (index < str.length) {
    if (/[*?{}()[\]]/.test(str[index])) {
      return true;
    }

    if (str[index] === '\\') {
      var open = str[index + 1];
      index += 2;
      var close = chars[open];

      if (close) {
        var n = str.indexOf(close, index);

        if (n !== -1) {
          index = n + 1;
        }
      }

      if (str[index] === '!') {
        return true;
      }
    } else {
      index++;
    }
  }

  return false;
};

var isGlob$2 = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var check = strictCheck; // optionally relax check

  if (options && options.strict === false) {
    check = relaxedCheck;
  }

  return check(str);
};

var isGlob$1 = isGlob$2;
var pathPosixDirname = require$$0$2.posix.dirname;
var isWin32 = require$$2$1.platform() === 'win32';
var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 * @returns {string}
 */

var globParent$1 = function globParent(str, opts) {
  var options = Object.assign({
    flipBackslashes: true
  }, opts); // flip windows path separators

  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  } // special case for strings ending in enclosure containing path separator


  if (enclosure.test(str)) {
    str += slash;
  } // preserves full path in case of trailing path separator


  str += 'a'; // remove path parts that are globby

  do {
    str = pathPosixDirname(str);
  } while (isGlob$1(str) || globby.test(str)); // remove escape chars and return result


  return str.replace(escaped, '$1');
};

var utils$3 = {};

(function (exports) {
  exports.isInteger = function (num) {
    if (typeof num === 'number') {
      return Number.isInteger(num);
    }

    if (typeof num === 'string' && num.trim() !== '') {
      return Number.isInteger(Number(num));
    }

    return false;
  };
  /**
   * Find a node of the given type
   */


  exports.find = function (node, type) {
    return node.nodes.find(function (node) {
      return node.type === type;
    });
  };
  /**
   * Find a node of the given type
   */


  exports.exceedsLimit = function (min, max) {
    var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var limit = arguments.length > 3 ? arguments[3] : undefined;
    if (limit === false) return false;
    if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
    return (Number(max) - Number(min)) / Number(step) >= limit;
  };
  /**
   * Escape the given node with '\\' before node.value
   */


  exports.escapeNode = function (block) {
    var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var type = arguments.length > 2 ? arguments[2] : undefined;
    var node = block.nodes[n];
    if (!node) return;

    if (type && node.type === type || node.type === 'open' || node.type === 'close') {
      if (node.escaped !== true) {
        node.value = '\\' + node.value;
        node.escaped = true;
      }
    }
  };
  /**
   * Returns true if the given brace node should be enclosed in literal braces
   */


  exports.encloseBrace = function (node) {
    if (node.type !== 'brace') return false;

    if (node.commas >> 0 + node.ranges >> 0 === 0) {
      node.invalid = true;
      return true;
    }

    return false;
  };
  /**
   * Returns true if a brace node is invalid.
   */


  exports.isInvalidBrace = function (block) {
    if (block.type !== 'brace') return false;
    if (block.invalid === true || block.dollar) return true;

    if (block.commas >> 0 + block.ranges >> 0 === 0) {
      block.invalid = true;
      return true;
    }

    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }

    return false;
  };
  /**
   * Returns true if a node is an open or close node
   */


  exports.isOpenOrClose = function (node) {
    if (node.type === 'open' || node.type === 'close') {
      return true;
    }

    return node.open === true || node.close === true;
  };
  /**
   * Reduce an array of text nodes.
   */


  exports.reduce = function (nodes) {
    return nodes.reduce(function (acc, node) {
      if (node.type === 'text') acc.push(node.value);
      if (node.type === 'range') node.type = 'text';
      return acc;
    }, []);
  };
  /**
   * Flatten an array
   */


  exports.flatten = function () {
    var result = [];

    var flat = function flat(arr) {
      for (var i = 0; i < arr.length; i++) {
        var ele = arr[i];
        Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
      }

      return result;
    };

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    flat(args);
    return result;
  };
})(utils$3);

var utils$2 = utils$3;

var stringify$4 = function stringify$4(ast) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var stringify = function stringify(node) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var invalidBlock = options.escapeInvalid && utils$2.isInvalidBrace(parent);
    var invalidNode = node.invalid === true && options.escapeInvalid === true;
    var output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && utils$2.isOpenOrClose(node)) {
        return '\\' + node.value;
      }

      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = node.nodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var child = _step3.value;
          output += stringify(child);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }

    return output;
  };

  return stringify(ast);
};
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */


var isNumber$2 = function isNumber$2(num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }

  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }

  return false;
};
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */


var isNumber$1 = isNumber$2;

var toRegexRange$1 = function toRegexRange$1(min, max, options) {
  if (isNumber$1(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if (isNumber$1(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  var opts = _objectSpread({
    relaxZeros: true
  }, options);

  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  var relax = String(opts.relaxZeros);
  var shorthand = String(opts.shorthand);
  var capture = String(opts.capture);
  var wrap = String(opts.wrap);
  var cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange$1.cache[cacheKey].result;
  }

  var a = Math.min(min, max);
  var b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    var result = min + '|' + max;

    if (opts.capture) {
      return "(".concat(result, ")");
    }

    if (opts.wrap === false) {
      return result;
    }

    return "(?:".concat(result, ")");
  }

  var isPadded = hasPadding(min) || hasPadding(max);
  var state = {
    min: min,
    max: max,
    a: a,
    b: b
  };
  var positives = [];
  var negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    var newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives);

  if (opts.capture === true) {
    state.result = "(".concat(state.result, ")");
  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
    state.result = "(?:".concat(state.result, ")");
  }

  toRegexRange$1.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  var onlyNegative = filterPatterns(neg, pos, '-', false) || [];
  var onlyPositive = filterPatterns(pos, neg, '', false) || [];
  var intersected = filterPatterns(neg, pos, '-?', true) || [];
  var subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  var nines = 1;
  var zeros = 1;
  var stop = countNines(min, nines);
  var stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops = _toConsumableArray(stops);
  stops.sort(compare);
  return stops;
}
/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */


function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return {
      pattern: start,
      count: [],
      digits: 0
    };
  }

  var zipped = zip(start, stop);
  var digits = zipped.length;
  var pattern = '';
  var count = 0;

  for (var i = 0; i < digits; i++) {
    var _zipped$i = _slicedToArray(zipped[i], 2),
        startDigit = _zipped$i[0],
        stopDigit = _zipped$i[1];

    if (startDigit === stopDigit) {
      pattern += startDigit;
    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit);
    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return {
    pattern: pattern,
    count: [count],
    digits: digits
  };
}

function splitToPatterns(min, max, tok, options) {
  var ranges = splitToRanges(min, max);
  var tokens = [];
  var start = min;
  var prev;

  for (var i = 0; i < ranges.length; i++) {
    var _max = ranges[i];
    var obj = rangeToPattern(String(start), String(_max), options);
    var _zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = _max + 1;
      continue;
    }

    if (tok.isPadded) {
      _zeros = padZeros(_max, tok, options);
    }

    obj.string = _zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = _max + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  var result = [];
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = arr[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var ele = _step4.value;
      var string = ele.string; // only push if _both_ are negative...

      if (!intersection && !contains(comparison, 'string', string)) {
        result.push(prefix + string);
      } // or _both_ are positive


      if (intersection && contains(comparison, 'string', string)) {
        result.push(prefix + string);
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return result;
}
/**
 * Zip strings
 */


function zip(a, b) {
  var arr = [];

  for (var i = 0; i < a.length; i++) {
    arr.push([a[i], b[i]]);
  }

  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(function (ele) {
    return ele[key] === val;
  });
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - integer % Math.pow(10, zeros);
}

function toQuantifier(digits) {
  var _digits = _slicedToArray(digits, 2),
      _digits$ = _digits[0],
      start = _digits$ === void 0 ? 0 : _digits$,
      _digits$2 = _digits[1],
      stop = _digits$2 === void 0 ? '' : _digits$2;

  if (stop || start > 1) {
    return "{".concat(start + (stop ? ',' + stop : ''), "}");
  }

  return '';
}

function toCharacterClass(a, b, options) {
  return "[".concat(a).concat(b - a === 1 ? '' : '-').concat(b, "]");
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  var diff = Math.abs(tok.maxLen - String(value).length);
  var relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';

    case 1:
      return relax ? '0?' : '0';

    case 2:
      return relax ? '0{0,2}' : '00';

    default:
      {
        return relax ? "0{0,".concat(diff, "}") : "0{".concat(diff, "}");
      }
  }
}
/**
 * Cache
 */


toRegexRange$1.cache = {};

toRegexRange$1.clearCache = function () {
  return toRegexRange$1.cache = {};
};
/**
 * Expose `toRegexRange`
 */


var toRegexRange_1 = toRegexRange$1;
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */

var util = require$$2;
var toRegexRange = toRegexRange_1;

var isObject = function isObject(val) {
  return val !== null && _typeof(val) === 'object' && !Array.isArray(val);
};

var transform = function transform(toNumber) {
  return function (value) {
    return toNumber === true ? Number(value) : String(value);
  };
};

var isValidValue = function isValidValue(value) {
  return typeof value === 'number' || typeof value === 'string' && value !== '';
};

var isNumber = function isNumber(num) {
  return Number.isInteger(+num);
};

var zeros = function zeros(input) {
  var value = "".concat(input);
  var index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;

  while (value[++index] === '0') {
    ;
  }

  return index > 0;
};

var stringify$3 = function stringify$3(start, end, options) {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }

  return options.stringify === true;
};

var pad = function pad(input, maxLength, toNumber) {
  if (maxLength > 0) {
    var dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');
  }

  if (toNumber === false) {
    return String(input);
  }

  return input;
};

var toMaxLen = function toMaxLen(input, maxLength) {
  var negative = input[0] === '-' ? '-' : '';

  if (negative) {
    input = input.slice(1);
    maxLength--;
  }

  while (input.length < maxLength) {
    input = '0' + input;
  }

  return negative ? '-' + input : input;
};

var toSequence = function toSequence(parts, options) {
  parts.negatives.sort(function (a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  });
  parts.positives.sort(function (a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  });
  var prefix = options.capture ? '' : '?:';
  var positives = '';
  var negatives = '';
  var result;

  if (parts.positives.length) {
    positives = parts.positives.join('|');
  }

  if (parts.negatives.length) {
    negatives = "-(".concat(prefix).concat(parts.negatives.join('|'), ")");
  }

  if (positives && negatives) {
    result = "".concat(positives, "|").concat(negatives);
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return "(".concat(prefix).concat(result, ")");
  }

  return result;
};

var toRange = function toRange(a, b, isNumbers, options) {
  if (isNumbers) {
    return toRegexRange(a, b, _objectSpread({
      wrap: false
    }, options));
  }

  var start = String.fromCharCode(a);
  if (a === b) return start;
  var stop = String.fromCharCode(b);
  return "[".concat(start, "-").concat(stop, "]");
};

var toRegex = function toRegex(start, end, options) {
  if (Array.isArray(start)) {
    var wrap = options.wrap === true;
    var prefix = options.capture ? '' : '?:';
    return wrap ? "(".concat(prefix).concat(start.join('|'), ")") : start.join('|');
  }

  return toRegexRange(start, end, options);
};

var rangeError = function rangeError() {
  return new RangeError('Invalid range arguments: ' + util.inspect.apply(util, arguments));
};

var invalidRange = function invalidRange(start, end, options) {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

var invalidStep = function invalidStep(step, options) {
  if (options.strictRanges === true) {
    throw new TypeError("Expected step \"".concat(step, "\" to be a number"));
  }

  return [];
};

var fillNumbers = function fillNumbers(start, end) {
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var a = Number(start);
  var b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  } // fix negative zero


  if (a === 0) a = 0;
  if (b === 0) b = 0;
  var descending = a > b;
  var startString = String(start);
  var endString = String(end);
  var stepString = String(step);
  step = Math.max(Math.abs(step), 1);
  var padded = zeros(startString) || zeros(endString) || zeros(stepString);
  var maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  var toNumber = padded === false && stringify$3(start, end, options) === false;
  var format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  var parts = {
    negatives: [],
    positives: []
  };

  var push = function push(num) {
    return parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  };

  var range = [];
  var index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }

    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1 ? toSequence(parts, options) : toRegex(range, null, _objectSpread({
      wrap: false
    }, options));
  }

  return range;
};

var fillLetters = function fillLetters(start, end) {
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
    return invalidRange(start, end, options);
  }

  var format = options.transform || function (val) {
    return String.fromCharCode(val);
  };

  var a = "".concat(start).charCodeAt(0);
  var b = "".concat(end).charCodeAt(0);
  var descending = a > b;
  var min = Math.min(a, b);
  var max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return toRange(min, max, false, options);
  }

  var range = [];
  var index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, {
      wrap: false,
      options: options
    });
  }

  return range;
};

var fill$2 = function fill$2(start, end, step) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (end == null && isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return fill$2(start, end, 1, {
      transform: step
    });
  }

  if (isObject(step)) {
    return fill$2(start, end, 0, step);
  }

  var opts = _objectSpread({}, options);

  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject(step)) return invalidStep(step, opts);
    return fill$2(start, end, 1, step);
  }

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

var fillRange = fill$2;
var fill$1 = fillRange;
var utils$1 = utils$3;

var compile$1 = function compile$1(ast) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var walk = function walk(node) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var invalidBlock = utils$1.isInvalidBrace(parent);
    var invalidNode = node.invalid === true && options.escapeInvalid === true;
    var invalid = invalidBlock === true || invalidNode === true;
    var prefix = options.escapeInvalid === true ? '\\' : '';
    var output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }

    if (node.isClose === true) {
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? prefix + node.value : '(';
    }

    if (node.type === 'close') {
      return invalid ? prefix + node.value : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      var args = utils$1.reduce(node.nodes);
      var range = fill$1.apply(void 0, _toConsumableArray(args).concat([_objectSpread({}, options, {
        wrap: false,
        toRegex: true
      })]));

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? "(".concat(range, ")") : range;
      }
    }

    if (node.nodes) {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = node.nodes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var child = _step5.value;
          output += walk(child, node);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }

    return output;
  };

  return walk(ast);
};

var compile_1 = compile$1;
var fill = fillRange;
var stringify$2 = stringify$4;
var utils = utils$3;

var append = function append() {
  var queue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var stash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var enclose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var result = [];
  queue = [].concat(queue);
  stash = [].concat(stash);
  if (!stash.length) return queue;

  if (!queue.length) {
    return enclose ? utils.flatten(stash).map(function (ele) {
      return "{".concat(ele, "}");
    }) : stash;
  }

  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = queue[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      var item = _step6.value;

      if (Array.isArray(item)) {
        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
          for (var _iterator7 = item[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
            var value = _step7.value;
            result.push(append(value, stash, enclose));
          }
        } catch (err) {
          _didIteratorError7 = true;
          _iteratorError7 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
              _iterator7["return"]();
            }
          } finally {
            if (_didIteratorError7) {
              throw _iteratorError7;
            }
          }
        }
      } else {
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = stash[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var ele = _step8.value;
            if (enclose === true && typeof ele === 'string') ele = "{".concat(ele, "}");
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
              _iterator8["return"]();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
        _iterator6["return"]();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }

  return utils.flatten(result);
};

var expand$1 = function expand$1(ast) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  var walk = function walk(node) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    node.queue = [];
    var p = parent;
    var q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify$2(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      var args = utils.reduce(node.nodes);

      if (utils.exceedsLimit.apply(utils, _toConsumableArray(args).concat([options.step, rangeLimit]))) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      var range = fill.apply(void 0, _toConsumableArray(args).concat([options]));

      if (range.length === 0) {
        range = stringify$2(node, options);
      }

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
    }

    var enclose = utils.encloseBrace(node);
    var queue = node.queue;
    var block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (var i = 0; i < node.nodes.length; i++) {
      var child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push(append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push(append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return utils.flatten(walk(ast));
};

var expand_1 = expand$1;
var constants$1 = {
  MAX_LENGTH: 1024 * 64,
  // Digits
  CHAR_0: '0',

  /* 0 */
  CHAR_9: '9',

  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A',

  /* A */
  CHAR_LOWERCASE_A: 'a',

  /* a */
  CHAR_UPPERCASE_Z: 'Z',

  /* Z */
  CHAR_LOWERCASE_Z: 'z',

  /* z */
  CHAR_LEFT_PARENTHESES: '(',

  /* ( */
  CHAR_RIGHT_PARENTHESES: ')',

  /* ) */
  CHAR_ASTERISK: '*',

  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&',

  /* & */
  CHAR_AT: '@',

  /* @ */
  CHAR_BACKSLASH: '\\',

  /* \ */
  CHAR_BACKTICK: '`',

  /* ` */
  CHAR_CARRIAGE_RETURN: '\r',

  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^',

  /* ^ */
  CHAR_COLON: ':',

  /* : */
  CHAR_COMMA: ',',

  /* , */
  CHAR_DOLLAR: '$',

  /* . */
  CHAR_DOT: '.',

  /* . */
  CHAR_DOUBLE_QUOTE: '"',

  /* " */
  CHAR_EQUAL: '=',

  /* = */
  CHAR_EXCLAMATION_MARK: '!',

  /* ! */
  CHAR_FORM_FEED: '\f',

  /* \f */
  CHAR_FORWARD_SLASH: '/',

  /* / */
  CHAR_HASH: '#',

  /* # */
  CHAR_HYPHEN_MINUS: '-',

  /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<',

  /* < */
  CHAR_LEFT_CURLY_BRACE: '{',

  /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[',

  /* [ */
  CHAR_LINE_FEED: '\n',

  /* \n */
  CHAR_NO_BREAK_SPACE: "\xA0",

  /* \u00A0 */
  CHAR_PERCENT: '%',

  /* % */
  CHAR_PLUS: '+',

  /* + */
  CHAR_QUESTION_MARK: '?',

  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>',

  /* > */
  CHAR_RIGHT_CURLY_BRACE: '}',

  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']',

  /* ] */
  CHAR_SEMICOLON: ';',

  /* ; */
  CHAR_SINGLE_QUOTE: '\'',

  /* ' */
  CHAR_SPACE: ' ',

  /*   */
  CHAR_TAB: '\t',

  /* \t */
  CHAR_UNDERSCORE: '_',

  /* _ */
  CHAR_VERTICAL_LINE: '|',

  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
  /* \uFEFF */

};
var stringify$1 = stringify$4;
/**
 * Constants
 */

var MAX_LENGTH = constants$1.MAX_LENGTH,
    CHAR_BACKSLASH = constants$1.CHAR_BACKSLASH,
    CHAR_BACKTICK = constants$1.CHAR_BACKTICK,
    CHAR_COMMA = constants$1.CHAR_COMMA,
    CHAR_DOT = constants$1.CHAR_DOT,
    CHAR_LEFT_PARENTHESES = constants$1.CHAR_LEFT_PARENTHESES,
    CHAR_RIGHT_PARENTHESES = constants$1.CHAR_RIGHT_PARENTHESES,
    CHAR_LEFT_CURLY_BRACE = constants$1.CHAR_LEFT_CURLY_BRACE,
    CHAR_RIGHT_CURLY_BRACE = constants$1.CHAR_RIGHT_CURLY_BRACE,
    CHAR_LEFT_SQUARE_BRACKET = constants$1.CHAR_LEFT_SQUARE_BRACKET,
    CHAR_RIGHT_SQUARE_BRACKET = constants$1.CHAR_RIGHT_SQUARE_BRACKET,
    CHAR_DOUBLE_QUOTE = constants$1.CHAR_DOUBLE_QUOTE,
    CHAR_SINGLE_QUOTE = constants$1.CHAR_SINGLE_QUOTE,
    CHAR_NO_BREAK_SPACE = constants$1.CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE = constants$1.CHAR_ZERO_WIDTH_NOBREAK_SPACE;
/**
 * parse
 */

var parse$1 = function parse$1(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  var opts = options || {};
  var max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  if (input.length > max) {
    throw new SyntaxError("Input length (".concat(input.length, "), exceeds max characters (").concat(max, ")"));
  }

  var ast = {
    type: 'root',
    input: input,
    nodes: []
  };
  var stack = [ast];
  var block = ast;
  var prev = ast;
  var brackets = 0;
  var length = input.length;
  var index = 0;
  var depth = 0;
  var value;
  /**
   * Helpers
   */

  var advance = function advance() {
    return input[index++];
  };

  var push = function push(node) {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({
    type: 'bos'
  });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();
    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
      continue;
    }
    /**
     * Escaped chars
     */


    if (value === CHAR_BACKSLASH) {
      push({
        type: 'text',
        value: (options.keepEscaping ? value : '') + advance()
      });
      continue;
    }
    /**
     * Right square bracket (literal): ']'
     */


    if (value === CHAR_RIGHT_SQUARE_BRACKET) {
      push({
        type: 'text',
        value: '\\' + value
      });
      continue;
    }
    /**
     * Left square bracket: '['
     */


    if (value === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;
      var next = void 0;

      while (index < length && (next = advance())) {
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }

        if (next === CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({
        type: 'text',
        value: value
      });
      continue;
    }
    /**
     * Parentheses
     */


    if (value === CHAR_LEFT_PARENTHESES) {
      block = push({
        type: 'paren',
        nodes: []
      });
      stack.push(block);
      push({
        type: 'text',
        value: value
      });
      continue;
    }

    if (value === CHAR_RIGHT_PARENTHESES) {
      if (block.type !== 'paren') {
        push({
          type: 'text',
          value: value
        });
        continue;
      }

      block = stack.pop();
      push({
        type: 'text',
        value: value
      });
      block = stack[stack.length - 1];
      continue;
    }
    /**
     * Quotes: '|"|`
     */


    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
      var _open = value;

      var _next = void 0;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (_next = advance())) {
        if (_next === CHAR_BACKSLASH) {
          value += _next + advance();
          continue;
        }

        if (_next === _open) {
          if (options.keepQuotes === true) value += _next;
          break;
        }

        value += _next;
      }

      push({
        type: 'text',
        value: value
      });
      continue;
    }
    /**
     * Left curly brace: '{'
     */


    if (value === CHAR_LEFT_CURLY_BRACE) {
      depth++;
      var dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      var brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar: dollar,
        depth: depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };
      block = push(brace);
      stack.push(block);
      push({
        type: 'open',
        value: value
      });
      continue;
    }
    /**
     * Right curly brace: '}'
     */


    if (value === CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== 'brace') {
        push({
          type: 'text',
          value: value
        });
        continue;
      }

      var type = 'close';
      block = stack.pop();
      block.close = true;
      push({
        type: type,
        value: value
      });
      depth--;
      block = stack[stack.length - 1];
      continue;
    }
    /**
     * Comma: ','
     */


    if (value === CHAR_COMMA && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;

        var _open2 = block.nodes.shift();

        block.nodes = [_open2, {
          type: 'text',
          value: stringify$1(block)
        }];
      }

      push({
        type: 'comma',
        value: value
      });
      block.commas++;
      continue;
    }
    /**
     * Dot: '.'
     */


    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
      var siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({
          type: 'text',
          value: value
        });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();
        var before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({
        type: 'dot',
        value: value
      });
      continue;
    }
    /**
     * Text
     */


    push({
      type: 'text',
      value: value
    });
  } // Mark imbalanced braces and brackets as invalid


  do {
    block = stack.pop();

    if (block.type !== 'root') {
      var _parent$nodes;

      block.nodes.forEach(function (node) {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      }); // get the location of the block on parent.nodes (block's siblings)

      var parent = stack[stack.length - 1];

      var _index2 = parent.nodes.indexOf(block); // replace the (invalid) block with it's nodes


      (_parent$nodes = parent.nodes).splice.apply(_parent$nodes, [_index2, 1].concat(_toConsumableArray(block.nodes)));
    }
  } while (stack.length > 0);

  push({
    type: 'eos'
  });
  return ast;
};

var parse_1 = parse$1;
var stringify = stringify$4;
var compile = compile_1;
var expand = expand_1;
var parse = parse_1;
/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

var braces$1 = function braces$1(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var output = [];

  if (Array.isArray(input)) {
    var _iteratorNormalCompletion9 = true;
    var _didIteratorError9 = false;
    var _iteratorError9 = undefined;

    try {
      for (var _iterator9 = input[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
        var pattern = _step9.value;
        var result = braces$1.create(pattern, options);

        if (Array.isArray(result)) {
          var _output;

          (_output = output).push.apply(_output, _toConsumableArray(result));
        } else {
          output.push(result);
        }
      }
    } catch (err) {
      _didIteratorError9 = true;
      _iteratorError9 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
          _iterator9["return"]();
        }
      } finally {
        if (_didIteratorError9) {
          throw _iteratorError9;
        }
      }
    }
  } else {
    output = [].concat(braces$1.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = _toConsumableArray(new Set(output));
  }

  return output;
};
/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */


braces$1.parse = function (input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return parse(input, options);
};
/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */


braces$1.stringify = function (input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof input === 'string') {
    return stringify(braces$1.parse(input, options), options);
  }

  return stringify(input, options);
};
/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */


braces$1.compile = function (input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof input === 'string') {
    input = braces$1.parse(input, options);
  }

  return compile(input, options);
};
/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */


braces$1.expand = function (input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof input === 'string') {
    input = braces$1.parse(input, options);
  }

  var result = expand(input, options); // filter out empty strings if specified

  if (options.noempty === true) {
    result = result.filter(Boolean);
  } // filter out duplicates if specified


  if (options.nodupes === true) {
    result = _toConsumableArray(new Set(result));
  }

  return result;
};
/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */


braces$1.create = function (input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (input === '' || input.length < 3) {
    return [input];
  }

  return options.expand !== true ? braces$1.compile(input, options) : braces$1.expand(input, options);
};
/**
 * Expose "braces"
 */


var braces_1 = braces$1;
var require$$0 = ["3dm", "3ds", "3g2", "3gp", "7z", "a", "aac", "adp", "ai", "aif", "aiff", "alz", "ape", "apk", "appimage", "ar", "arj", "asf", "au", "avi", "bak", "baml", "bh", "bin", "bk", "bmp", "btif", "bz2", "bzip2", "cab", "caf", "cgm", "class", "cmx", "cpio", "cr2", "cur", "dat", "dcm", "deb", "dex", "djvu", "dll", "dmg", "dng", "doc", "docm", "docx", "dot", "dotm", "dra", "DS_Store", "dsk", "dts", "dtshd", "dvb", "dwg", "dxf", "ecelp4800", "ecelp7470", "ecelp9600", "egg", "eol", "eot", "epub", "exe", "f4v", "fbs", "fh", "fla", "flac", "flatpak", "fli", "flv", "fpx", "fst", "fvt", "g3", "gh", "gif", "graffle", "gz", "gzip", "h261", "h263", "h264", "icns", "ico", "ief", "img", "ipa", "iso", "jar", "jpeg", "jpg", "jpgv", "jpm", "jxr", "key", "ktx", "lha", "lib", "lvp", "lz", "lzh", "lzma", "lzo", "m3u", "m4a", "m4v", "mar", "mdi", "mht", "mid", "midi", "mj2", "mka", "mkv", "mmr", "mng", "mobi", "mov", "movie", "mp3", "mp4", "mp4a", "mpeg", "mpg", "mpga", "mxu", "nef", "npx", "numbers", "nupkg", "o", "odp", "ods", "odt", "oga", "ogg", "ogv", "otf", "ott", "pages", "pbm", "pcx", "pdb", "pdf", "pea", "pgm", "pic", "png", "pnm", "pot", "potm", "potx", "ppa", "ppam", "ppm", "pps", "ppsm", "ppsx", "ppt", "pptm", "pptx", "psd", "pya", "pyc", "pyo", "pyv", "qt", "rar", "ras", "raw", "resources", "rgb", "rip", "rlc", "rmf", "rmvb", "rpm", "rtf", "rz", "s3m", "s7z", "scpt", "sgi", "shar", "snap", "sil", "sketch", "slk", "smv", "snk", "so", "stl", "suo", "sub", "swf", "tar", "tbz", "tbz2", "tga", "tgz", "thmx", "tif", "tiff", "tlz", "ttc", "ttf", "txz", "udf", "uvh", "uvi", "uvm", "uvp", "uvs", "uvu", "viv", "vob", "war", "wav", "wax", "wbmp", "wdp", "weba", "webm", "webp", "whl", "wim", "wm", "wma", "wmv", "wmx", "woff", "woff2", "wrm", "wvx", "xbm", "xif", "xla", "xlam", "xls", "xlsb", "xlsm", "xlsx", "xlt", "xltm", "xltx", "xm", "xmind", "xpi", "xpm", "xwd", "xz", "z", "zip", "zipx"];
var binaryExtensions$1 = require$$0;
var path = require$$0$2;
var binaryExtensions = binaryExtensions$1;
var extensions = new Set(binaryExtensions);

var isBinaryPath$1 = function isBinaryPath$1(filePath) {
  return extensions.has(path.extname(filePath).slice(1).toLowerCase());
};

var constants = {};

(function (exports) {
  var sep = require$$0$2.sep;
  var _process = process,
      platform = _process.platform;
  var os = require$$2$1;
  exports.EV_ALL = 'all';
  exports.EV_READY = 'ready';
  exports.EV_ADD = 'add';
  exports.EV_CHANGE = 'change';
  exports.EV_ADD_DIR = 'addDir';
  exports.EV_UNLINK = 'unlink';
  exports.EV_UNLINK_DIR = 'unlinkDir';
  exports.EV_RAW = 'raw';
  exports.EV_ERROR = 'error';
  exports.STR_DATA = 'data';
  exports.STR_END = 'end';
  exports.STR_CLOSE = 'close';
  exports.FSEVENT_CREATED = 'created';
  exports.FSEVENT_MODIFIED = 'modified';
  exports.FSEVENT_DELETED = 'deleted';
  exports.FSEVENT_MOVED = 'moved';
  exports.FSEVENT_CLONED = 'cloned';
  exports.FSEVENT_UNKNOWN = 'unknown';
  exports.FSEVENT_TYPE_FILE = 'file';
  exports.FSEVENT_TYPE_DIRECTORY = 'directory';
  exports.FSEVENT_TYPE_SYMLINK = 'symlink';
  exports.KEY_LISTENERS = 'listeners';
  exports.KEY_ERR = 'errHandlers';
  exports.KEY_RAW = 'rawEmitters';
  exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];
  exports.DOT_SLASH = ".".concat(sep);
  exports.BACK_SLASH_RE = /\\/g;
  exports.DOUBLE_SLASH_RE = /\/\//;
  exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
  exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
  exports.REPLACER_RE = /^\.[/\\]/;
  exports.SLASH = '/';
  exports.SLASH_SLASH = '//';
  exports.BRACE_START = '{';
  exports.BANG = '!';
  exports.ONE_DOT = '.';
  exports.TWO_DOTS = '..';
  exports.STAR = '*';
  exports.GLOBSTAR = '**';
  exports.ROOT_GLOBSTAR = '/**/*';
  exports.SLASH_GLOBSTAR = '/**';
  exports.DIR_SUFFIX = 'Dir';
  exports.ANYMATCH_OPTS = {
    dot: true
  };
  exports.STRING_TYPE = 'string';
  exports.FUNCTION_TYPE = 'function';
  exports.EMPTY_STR = '';

  exports.EMPTY_FN = function () {};

  exports.IDENTITY_FN = function (val) {
    return val;
  };

  exports.isWindows = platform === 'win32';
  exports.isMacos = platform === 'darwin';
  exports.isLinux = platform === 'linux';
  exports.isIBMi = os.type() === 'OS400';
})(constants);

var fs$2 = require$$0$1;
var sysPath$2 = require$$0$2;
var promisify$2 = require$$2.promisify;
var isBinaryPath = isBinaryPath$1;
var isWindows$1 = constants.isWindows,
    isLinux = constants.isLinux,
    EMPTY_FN$2 = constants.EMPTY_FN,
    EMPTY_STR$1 = constants.EMPTY_STR,
    KEY_LISTENERS = constants.KEY_LISTENERS,
    KEY_ERR = constants.KEY_ERR,
    KEY_RAW = constants.KEY_RAW,
    HANDLER_KEYS = constants.HANDLER_KEYS,
    EV_CHANGE$2 = constants.EV_CHANGE,
    EV_ADD$2 = constants.EV_ADD,
    EV_ADD_DIR$2 = constants.EV_ADD_DIR,
    EV_ERROR$2 = constants.EV_ERROR,
    STR_DATA$1 = constants.STR_DATA,
    STR_END$2 = constants.STR_END,
    BRACE_START$1 = constants.BRACE_START,
    STAR = constants.STAR;
var THROTTLE_MODE_WATCH = 'watch';
var open = promisify$2(fs$2.open);
var stat$2 = promisify$2(fs$2.stat);
var lstat$1 = promisify$2(fs$2.lstat);
var close = promisify$2(fs$2.close);
var fsrealpath = promisify$2(fs$2.realpath);
var statMethods$1 = {
  lstat: lstat$1,
  stat: stat$2
}; // TODO: emit errors properly. Example: EMFILE on Macos.

var foreach = function foreach(val, fn) {
  if (val instanceof Set) {
    val.forEach(fn);
  } else {
    fn(val);
  }
};

var addAndConvert = function addAndConvert(main, prop, item) {
  var container = main[prop];

  if (!(container instanceof Set)) {
    main[prop] = container = new Set([container]);
  }

  container.add(item);
};

var clearItem = function clearItem(cont) {
  return function (key) {
    var set = cont[key];

    if (set instanceof Set) {
      set.clear();
    } else {
      delete cont[key];
    }
  };
};

var delFromSet = function delFromSet(main, prop, item) {
  var container = main[prop];

  if (container instanceof Set) {
    container["delete"](item);
  } else if (container === item) {
    delete main[prop];
  }
};

var isEmptySet = function isEmptySet(val) {
  return val instanceof Set ? val.size === 0 : !val;
};
/**
 * @typedef {String} Path
 */
// fs_watch helpers
// object to hold per-process fs_watch instances
// (may be shared across chokidar FSWatcher instances)

/**
 * @typedef {Object} FsWatchContainer
 * @property {Set} listeners
 * @property {Set} errHandlers
 * @property {Set} rawEmitters
 * @property {fs.FSWatcher=} watcher
 * @property {Boolean=} watcherUnusable
 */

/**
 * @type {Map<String,FsWatchContainer>}
 */


var FsWatchInstances = new Map();
/**
 * Instantiates the fs_watch interface
 * @param {String} path to be watched
 * @param {Object} options to be passed to fs_watch
 * @param {Function} listener main event handler
 * @param {Function} errHandler emits info about errors
 * @param {Function} emitRaw emits raw event data
 * @returns {fs.FSWatcher} new fsevents instance
 */

function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
  var handleEvent = function handleEvent(rawEvent, evPath) {
    listener(path);
    emitRaw(rawEvent, evPath, {
      watchedPath: path
    }); // emit based on events occurring for files from a directory's watcher in
    // case the file's watcher misses it (and rely on throttling to de-dupe)

    if (evPath && path !== evPath) {
      fsWatchBroadcast(sysPath$2.resolve(path, evPath), KEY_LISTENERS, sysPath$2.join(path, evPath));
    }
  };

  try {
    return fs$2.watch(path, options, handleEvent);
  } catch (error) {
    errHandler(error);
  }
}
/**
 * Helper for passing fs_watch event data to a collection of listeners
 * @param {Path} fullPath absolute path bound to fs_watch instance
 * @param {String} type listener type
 * @param {*=} val1 arguments to be passed to listeners
 * @param {*=} val2
 * @param {*=} val3
 */


var fsWatchBroadcast = function fsWatchBroadcast(fullPath, type, val1, val2, val3) {
  var cont = FsWatchInstances.get(fullPath);
  if (!cont) return;
  foreach(cont[type], function (listener) {
    listener(val1, val2, val3);
  });
};
/**
 * Instantiates the fs_watch interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path
 * @param {String} fullPath absolute path
 * @param {Object} options to be passed to fs_watch
 * @param {Object} handlers container for event listener functions
 */


var setFsWatchListener = function setFsWatchListener(path, fullPath, options, handlers) {
  var listener = handlers.listener,
      errHandler = handlers.errHandler,
      rawEmitter = handlers.rawEmitter;
  var cont = FsWatchInstances.get(fullPath);
  /** @type {fs.FSWatcher=} */

  var watcher;

  if (!options.persistent) {
    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);
    return watcher.close.bind(watcher);
  }

  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_ERR, errHandler);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here
    fsWatchBroadcast.bind(null, fullPath, KEY_RAW));
    if (!watcher) return;
    watcher.on(EV_ERROR$2, function _callee(error) {
      var broadcastErr, fd;
      return regeneratorRuntime.async(function _callee$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
              cont.watcherUnusable = true; // documented since Node 10.4.1
              // Workaround for https://github.com/joyent/node/issues/4337

              if (!(isWindows$1 && error.code === 'EPERM')) {
                _context6.next = 16;
                break;
              }

              _context6.prev = 3;
              _context6.next = 6;
              return regeneratorRuntime.awrap(open(path, 'r'));

            case 6:
              fd = _context6.sent;
              _context6.next = 9;
              return regeneratorRuntime.awrap(close(fd));

            case 9:
              broadcastErr(error);
              _context6.next = 14;
              break;

            case 12:
              _context6.prev = 12;
              _context6.t0 = _context6["catch"](3);

            case 14:
              _context6.next = 17;
              break;

            case 16:
              broadcastErr(error);

            case 17:
            case "end":
              return _context6.stop();
          }
        }
      }, null, null, [[3, 12]]);
    });
    cont = {
      listeners: listener,
      errHandlers: errHandler,
      rawEmitters: rawEmitter,
      watcher: watcher
    };
    FsWatchInstances.set(fullPath, cont);
  } // const index = cont.listeners.indexOf(listener);
  // removes this instance's listeners and closes the underlying fs_watch
  // instance if there are no more listeners left


  return function () {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_ERR, errHandler);
    delFromSet(cont, KEY_RAW, rawEmitter);

    if (isEmptySet(cont.listeners)) {
      // Check to protect against issue gh-730.
      // if (cont.watcherUnusable) {
      cont.watcher.close(); // }

      FsWatchInstances["delete"](fullPath);
      HANDLER_KEYS.forEach(clearItem(cont));
      cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
}; // fs_watchFile helpers
// object to hold per-process fs_watchFile instances
// (may be shared across chokidar FSWatcher instances)


var FsWatchFileInstances = new Map();
/**
 * Instantiates the fs_watchFile interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path to be watched
 * @param {String} fullPath absolute path
 * @param {Object} options options to be passed to fs_watchFile
 * @param {Object} handlers container for event listener functions
 * @returns {Function} closer
 */

var setFsWatchFileListener = function setFsWatchFileListener(path, fullPath, options, handlers) {
  var listener = handlers.listener,
      rawEmitter = handlers.rawEmitter;
  var cont = FsWatchFileInstances.get(fullPath);
  var copts = cont && cont.options;

  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
    fs$2.unwatchFile(fullPath);
    cont = undefined;
  }
  /* eslint-enable no-unused-vars, prefer-destructuring */


  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    // TODO
    // listeners.add(listener);
    // rawEmitters.add(rawEmitter);
    cont = {
      listeners: listener,
      rawEmitters: rawEmitter,
      options: options,
      watcher: fs$2.watchFile(fullPath, options, function (curr, prev) {
        foreach(cont.rawEmitters, function (rawEmitter) {
          rawEmitter(EV_CHANGE$2, fullPath, {
            curr: curr,
            prev: prev
          });
        });
        var currmtime = curr.mtimeMs;

        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          foreach(cont.listeners, function (listener) {
            return listener(path, curr);
          });
        }
      })
    };
    FsWatchFileInstances.set(fullPath, cont);
  } // const index = cont.listeners.indexOf(listener);
  // Removes this instance's listeners and closes the underlying fs_watchFile
  // instance if there are no more listeners left.


  return function () {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_RAW, rawEmitter);

    if (isEmptySet(cont.listeners)) {
      FsWatchFileInstances["delete"](fullPath);
      fs$2.unwatchFile(fullPath);
      cont.options = cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};
/**
 * @mixin
 */


var NodeFsHandler$1 =
/*#__PURE__*/
function () {
  /**
   * @param {import("../index").FSWatcher} fsW
   */
  function NodeFsHandler(fsW) {
    _classCallCheck(this, NodeFsHandler);

    this.fsw = fsW;

    this._boundHandleError = function (error) {
      return fsW._handleError(error);
    };
  }
  /**
   * Watch file for changes with fs_watchFile or fs_watch.
   * @param {String} path to file or dir
   * @param {Function} listener on fs change
   * @returns {Function} closer for the watcher instance
   */


  _createClass(NodeFsHandler, [{
    key: "_watchWithNodeFs",
    value: function _watchWithNodeFs(path, listener) {
      var opts = this.fsw.options;
      var directory = sysPath$2.dirname(path);
      var basename = sysPath$2.basename(path);

      var parent = this.fsw._getWatchedDir(directory);

      parent.add(basename);
      var absolutePath = sysPath$2.resolve(path);
      var options = {
        persistent: opts.persistent
      };
      if (!listener) listener = EMPTY_FN$2;
      var closer;

      if (opts.usePolling) {
        options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
        closer = setFsWatchFileListener(path, absolutePath, options, {
          listener: listener,
          rawEmitter: this.fsw._emitRaw
        });
      } else {
        closer = setFsWatchListener(path, absolutePath, options, {
          listener: listener,
          errHandler: this._boundHandleError,
          rawEmitter: this.fsw._emitRaw
        });
      }

      return closer;
    }
    /**
     * Watch a file and emit add event if warranted.
     * @param {Path} file Path
     * @param {fs.Stats} stats result of fs_stat
     * @param {Boolean} initialAdd was the file added at watch instantiation?
     * @returns {Function} closer for the watcher instance
     */

  }, {
    key: "_handleFile",
    value: function _handleFile(file, stats, initialAdd) {
      var _this3 = this;

      if (this.fsw.closed) {
        return;
      }

      var dirname = sysPath$2.dirname(file);
      var basename = sysPath$2.basename(file);

      var parent = this.fsw._getWatchedDir(dirname); // stats is always present


      var prevStats = stats; // if the file is already being watched, do nothing

      if (parent.has(basename)) return;

      var listener = function listener(path, newStats) {
        var _newStats, at, mt, _at, _mt;

        return regeneratorRuntime.async(function listener$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (_this3.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt("return");

              case 2:
                if (!(!newStats || newStats.mtimeMs === 0)) {
                  _context7.next = 20;
                  break;
                }

                _context7.prev = 3;
                _context7.next = 6;
                return regeneratorRuntime.awrap(stat$2(file));

              case 6:
                _newStats = _context7.sent;

                if (!_this3.fsw.closed) {
                  _context7.next = 9;
                  break;
                }

                return _context7.abrupt("return");

              case 9:
                // Check that change event was not fired because of changed only accessTime.
                at = _newStats.atimeMs;
                mt = _newStats.mtimeMs;

                if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                  _this3.fsw._emit(EV_CHANGE$2, file, _newStats);
                }

                if (isLinux && prevStats.ino !== _newStats.ino) {
                  _this3.fsw._closeFile(path);

                  prevStats = _newStats;

                  _this3.fsw._addPathCloser(path, _this3._watchWithNodeFs(file, listener));
                } else {
                  prevStats = _newStats;
                }

                _context7.next = 18;
                break;

              case 15:
                _context7.prev = 15;
                _context7.t0 = _context7["catch"](3);

                // Fix issues where mtime is null but file is still present
                _this3.fsw._remove(dirname, basename);

              case 18:
                _context7.next = 21;
                break;

              case 20:
                if (parent.has(basename)) {
                  // Check that change event was not fired because of changed only accessTime.
                  _at = newStats.atimeMs;
                  _mt = newStats.mtimeMs;

                  if (!_at || _at <= _mt || _mt !== prevStats.mtimeMs) {
                    _this3.fsw._emit(EV_CHANGE$2, file, newStats);
                  }

                  prevStats = newStats;
                }

              case 21:
              case "end":
                return _context7.stop();
            }
          }
        }, null, null, [[3, 15]]);
      }; // kick off the watcher


      var closer = this._watchWithNodeFs(file, listener); // emit an add event if we're supposed to


      if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
        if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;

        this.fsw._emit(EV_ADD$2, file, stats);
      }

      return closer;
    }
    /**
     * Handle symlinks encountered while reading a dir.
     * @param {Object} entry returned by readdirp
     * @param {String} directory path of dir being read
     * @param {String} path of this item
     * @param {String} item basename of this item
     * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
     */

  }, {
    key: "_handleSymlink",
    value: function _handleSymlink(entry, directory, path, item) {
      var full, dir, linkPath;
      return regeneratorRuntime.async(function _handleSymlink$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              if (!this.fsw.closed) {
                _context8.next = 2;
                break;
              }

              return _context8.abrupt("return");

            case 2:
              full = entry.fullPath;
              dir = this.fsw._getWatchedDir(directory);

              if (this.fsw.options.followSymlinks) {
                _context8.next = 21;
                break;
              }

              // watch symlink directly (don't follow) and detect changes
              this.fsw._incrReadyCount();

              _context8.prev = 6;
              _context8.next = 9;
              return regeneratorRuntime.awrap(fsrealpath(path));

            case 9:
              linkPath = _context8.sent;
              _context8.next = 16;
              break;

            case 12:
              _context8.prev = 12;
              _context8.t0 = _context8["catch"](6);

              this.fsw._emitReady();

              return _context8.abrupt("return", true);

            case 16:
              if (!this.fsw.closed) {
                _context8.next = 18;
                break;
              }

              return _context8.abrupt("return");

            case 18:
              if (dir.has(item)) {
                if (this.fsw._symlinkPaths.get(full) !== linkPath) {
                  this.fsw._symlinkPaths.set(full, linkPath);

                  this.fsw._emit(EV_CHANGE$2, path, entry.stats);
                }
              } else {
                dir.add(item);

                this.fsw._symlinkPaths.set(full, linkPath);

                this.fsw._emit(EV_ADD$2, path, entry.stats);
              }

              this.fsw._emitReady();

              return _context8.abrupt("return", true);

            case 21:
              if (!this.fsw._symlinkPaths.has(full)) {
                _context8.next = 23;
                break;
              }

              return _context8.abrupt("return", true);

            case 23:
              this.fsw._symlinkPaths.set(full, true);

            case 24:
            case "end":
              return _context8.stop();
          }
        }
      }, null, this, [[6, 12]]);
    }
  }, {
    key: "_handleRead",
    value: function _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
      var _this4 = this;

      // Normalize the directory name on Windows
      directory = sysPath$2.join(directory, EMPTY_STR$1);

      if (!wh.hasGlob) {
        throttler = this.fsw._throttle('readdir', directory, 1000);
        if (!throttler) return;
      }

      var previous = this.fsw._getWatchedDir(wh.path);

      var current = new Set();

      var stream = this.fsw._readdirp(directory, {
        fileFilter: function fileFilter(entry) {
          return wh.filterPath(entry);
        },
        directoryFilter: function directoryFilter(entry) {
          return wh.filterDir(entry);
        },
        depth: 0
      }).on(STR_DATA$1, function _callee2(entry) {
        var item, path;
        return regeneratorRuntime.async(function _callee2$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!_this4.fsw.closed) {
                  _context9.next = 3;
                  break;
                }

                stream = undefined;
                return _context9.abrupt("return");

              case 3:
                item = entry.path;
                path = sysPath$2.join(directory, item);
                current.add(item);
                _context9.t0 = entry.stats.isSymbolicLink();

                if (!_context9.t0) {
                  _context9.next = 11;
                  break;
                }

                _context9.next = 10;
                return regeneratorRuntime.awrap(_this4._handleSymlink(entry, directory, path, item));

              case 10:
                _context9.t0 = _context9.sent;

              case 11:
                if (!_context9.t0) {
                  _context9.next = 13;
                  break;
                }

                return _context9.abrupt("return");

              case 13:
                if (!_this4.fsw.closed) {
                  _context9.next = 16;
                  break;
                }

                stream = undefined;
                return _context9.abrupt("return");

              case 16:
                // Files that present in current directory snapshot
                // but absent in previous are added to watch list and
                // emit `add` event.
                if (item === target || !target && !previous.has(item)) {
                  _this4.fsw._incrReadyCount(); // ensure relativeness of path is preserved in case of watcher reuse


                  path = sysPath$2.join(dir, sysPath$2.relative(dir, path));

                  _this4._addToNodeFs(path, initialAdd, wh, depth + 1);
                }

              case 17:
              case "end":
                return _context9.stop();
            }
          }
        });
      }).on(EV_ERROR$2, this._boundHandleError);

      return new Promise(function (resolve) {
        return stream.once(STR_END$2, function () {
          if (_this4.fsw.closed) {
            stream = undefined;
            return;
          }

          var wasThrottled = throttler ? throttler.clear() : false;
          resolve(); // Files that absent in current directory snapshot
          // but present in previous emit `remove` event
          // and are removed from @watched[directory].

          previous.getChildren().filter(function (item) {
            return item !== directory && !current.has(item) && ( // in case of intersecting globs;
            // a path may have been filtered out of this readdir, but
            // shouldn't be removed because it matches a different glob
            !wh.hasGlob || wh.filterPath({
              fullPath: sysPath$2.resolve(directory, item)
            }));
          }).forEach(function (item) {
            _this4.fsw._remove(directory, item);
          });
          stream = undefined; // one more time for any missed in case changes came in extremely quickly

          if (wasThrottled) _this4._handleRead(directory, false, wh, target, dir, depth, throttler);
        });
      });
    }
    /**
     * Read directory to add / remove files from `@watched` list and re-read it on change.
     * @param {String} dir fs path
     * @param {fs.Stats} stats
     * @param {Boolean} initialAdd
     * @param {Number} depth relative to user-supplied path
     * @param {String} target child path targeted for watch
     * @param {Object} wh Common watch helpers for this path
     * @param {String} realpath
     * @returns {Promise<Function>} closer for the watcher instance.
     */

  }, {
    key: "_handleDir",
    value: function _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
      var _this5 = this;

      var parentDir, tracked, throttler, closer, oDepth;
      return regeneratorRuntime.async(function _handleDir$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));
              tracked = parentDir.has(sysPath$2.basename(dir));

              if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
                if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);
              } // ensure dir is tracked (harmless if redundant)


              parentDir.add(sysPath$2.basename(dir));

              this.fsw._getWatchedDir(dir);

              oDepth = this.fsw.options.depth;

              if (!((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath))) {
                _context10.next = 13;
                break;
              }

              if (target) {
                _context10.next = 12;
                break;
              }

              _context10.next = 10;
              return regeneratorRuntime.awrap(this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler));

            case 10:
              if (!this.fsw.closed) {
                _context10.next = 12;
                break;
              }

              return _context10.abrupt("return");

            case 12:
              closer = this._watchWithNodeFs(dir, function (dirPath, stats) {
                // if current directory is removed, do nothing
                if (stats && stats.mtimeMs === 0) return;

                _this5._handleRead(dirPath, false, wh, target, dir, depth, throttler);
              });

            case 13:
              return _context10.abrupt("return", closer);

            case 14:
            case "end":
              return _context10.stop();
          }
        }
      }, null, this);
    }
    /**
     * Handle added file, directory, or glob pattern.
     * Delegates call to _handleFile / _handleDir after checks.
     * @param {String} path to file or ir
     * @param {Boolean} initialAdd was the file added at watch instantiation?
     * @param {Object} priorWh depth relative to user-supplied path
     * @param {Number} depth Child path actually targeted for watch
     * @param {String=} target Child path actually targeted for watch
     * @returns {Promise}
     */

  }, {
    key: "_addToNodeFs",
    value: function _addToNodeFs(path, initialAdd, priorWh, depth, target) {
      var ready, wh, stats, follow, closer, absPath, targetPath, _targetPath, parent;

      return regeneratorRuntime.async(function _addToNodeFs$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              ready = this.fsw._emitReady;

              if (!(this.fsw._isIgnored(path) || this.fsw.closed)) {
                _context11.next = 4;
                break;
              }

              ready();
              return _context11.abrupt("return", false);

            case 4:
              wh = this.fsw._getWatchHelpers(path, depth);

              if (!wh.hasGlob && priorWh) {
                wh.hasGlob = priorWh.hasGlob;
                wh.globFilter = priorWh.globFilter;

                wh.filterPath = function (entry) {
                  return priorWh.filterPath(entry);
                };

                wh.filterDir = function (entry) {
                  return priorWh.filterDir(entry);
                };
              } // evaluate what is at the path we're being asked to watch


              _context11.prev = 6;
              _context11.next = 9;
              return regeneratorRuntime.awrap(statMethods$1[wh.statMethod](wh.watchPath));

            case 9:
              stats = _context11.sent;

              if (!this.fsw.closed) {
                _context11.next = 12;
                break;
              }

              return _context11.abrupt("return");

            case 12:
              if (!this.fsw._isIgnored(wh.watchPath, stats)) {
                _context11.next = 15;
                break;
              }

              ready();
              return _context11.abrupt("return", false);

            case 15:
              follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START$1);

              if (!stats.isDirectory()) {
                _context11.next = 36;
                break;
              }

              absPath = sysPath$2.resolve(path);

              if (!follow) {
                _context11.next = 24;
                break;
              }

              _context11.next = 21;
              return regeneratorRuntime.awrap(fsrealpath(path));

            case 21:
              _context11.t0 = _context11.sent;
              _context11.next = 25;
              break;

            case 24:
              _context11.t0 = path;

            case 25:
              targetPath = _context11.t0;

              if (!this.fsw.closed) {
                _context11.next = 28;
                break;
              }

              return _context11.abrupt("return");

            case 28:
              _context11.next = 30;
              return regeneratorRuntime.awrap(this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath));

            case 30:
              closer = _context11.sent;

              if (!this.fsw.closed) {
                _context11.next = 33;
                break;
              }

              return _context11.abrupt("return");

            case 33:
              // preserve this symlink's target path
              if (absPath !== targetPath && targetPath !== undefined) {
                this.fsw._symlinkPaths.set(absPath, targetPath);
              }

              _context11.next = 59;
              break;

            case 36:
              if (!stats.isSymbolicLink()) {
                _context11.next = 58;
                break;
              }

              if (!follow) {
                _context11.next = 43;
                break;
              }

              _context11.next = 40;
              return regeneratorRuntime.awrap(fsrealpath(path));

            case 40:
              _context11.t1 = _context11.sent;
              _context11.next = 44;
              break;

            case 43:
              _context11.t1 = path;

            case 44:
              _targetPath = _context11.t1;

              if (!this.fsw.closed) {
                _context11.next = 47;
                break;
              }

              return _context11.abrupt("return");

            case 47:
              parent = sysPath$2.dirname(wh.watchPath);

              this.fsw._getWatchedDir(parent).add(wh.watchPath);

              this.fsw._emit(EV_ADD$2, wh.watchPath, stats);

              _context11.next = 52;
              return regeneratorRuntime.awrap(this._handleDir(parent, stats, initialAdd, depth, path, wh, _targetPath));

            case 52:
              closer = _context11.sent;

              if (!this.fsw.closed) {
                _context11.next = 55;
                break;
              }

              return _context11.abrupt("return");

            case 55:
              // preserve this symlink's target path
              if (_targetPath !== undefined) {
                this.fsw._symlinkPaths.set(sysPath$2.resolve(path), _targetPath);
              }

              _context11.next = 59;
              break;

            case 58:
              closer = this._handleFile(wh.watchPath, stats, initialAdd);

            case 59:
              ready();

              this.fsw._addPathCloser(path, closer);

              return _context11.abrupt("return", false);

            case 64:
              _context11.prev = 64;
              _context11.t2 = _context11["catch"](6);

              if (!this.fsw._handleError(_context11.t2)) {
                _context11.next = 69;
                break;
              }

              ready();
              return _context11.abrupt("return", path);

            case 69:
            case "end":
              return _context11.stop();
          }
        }
      }, null, this, [[6, 64]]);
    }
  }]);

  return NodeFsHandler;
}();

var nodefsHandler = NodeFsHandler$1;
var fseventsHandler = {
  exports: {}
};
var require$$3 =
/*@__PURE__*/
rollup.getAugmentedNamespace(fseventsImporter.fseventsImporter);
var fs$1 = require$$0$1;
var sysPath$1 = require$$0$2;
var promisify$1 = require$$2.promisify;
var fsevents;

try {
  fsevents = require$$3.getFsEvents();
} catch (error) {
  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);
}

if (fsevents) {
  // TODO: real check
  var mtch = process.version.match(/v(\d+)\.(\d+)/);

  if (mtch && mtch[1] && mtch[2]) {
    var _maj = Number.parseInt(mtch[1], 10);

    var _min = Number.parseInt(mtch[2], 10);

    if (_maj === 8 && _min < 16) {
      fsevents = undefined;
    }
  }
}

var EV_ADD$1 = constants.EV_ADD,
    EV_CHANGE$1 = constants.EV_CHANGE,
    EV_ADD_DIR$1 = constants.EV_ADD_DIR,
    EV_UNLINK$1 = constants.EV_UNLINK,
    EV_ERROR$1 = constants.EV_ERROR,
    STR_DATA = constants.STR_DATA,
    STR_END$1 = constants.STR_END,
    FSEVENT_CREATED = constants.FSEVENT_CREATED,
    FSEVENT_MODIFIED = constants.FSEVENT_MODIFIED,
    FSEVENT_DELETED = constants.FSEVENT_DELETED,
    FSEVENT_MOVED = constants.FSEVENT_MOVED,
    FSEVENT_UNKNOWN = constants.FSEVENT_UNKNOWN,
    FSEVENT_TYPE_FILE = constants.FSEVENT_TYPE_FILE,
    FSEVENT_TYPE_DIRECTORY = constants.FSEVENT_TYPE_DIRECTORY,
    FSEVENT_TYPE_SYMLINK = constants.FSEVENT_TYPE_SYMLINK,
    ROOT_GLOBSTAR = constants.ROOT_GLOBSTAR,
    DIR_SUFFIX = constants.DIR_SUFFIX,
    DOT_SLASH = constants.DOT_SLASH,
    FUNCTION_TYPE$1 = constants.FUNCTION_TYPE,
    EMPTY_FN$1 = constants.EMPTY_FN,
    IDENTITY_FN = constants.IDENTITY_FN;

var Depth = function Depth(value) {
  return isNaN(value) ? {} : {
    depth: value
  };
};

var stat$1 = promisify$1(fs$1.stat);
var lstat = promisify$1(fs$1.lstat);
var realpath = promisify$1(fs$1.realpath);
var statMethods = {
  stat: stat$1,
  lstat: lstat
};
/**
 * @typedef {String} Path
 */

/**
 * @typedef {Object} FsEventsWatchContainer
 * @property {Set<Function>} listeners
 * @property {Function} rawEmitter
 * @property {{stop: Function}} watcher
 */
// fsevents instance helper functions

/**
 * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)
 * @type {Map<Path,FsEventsWatchContainer>}
 */

var FSEventsWatchers = new Map(); // Threshold of duplicate path prefixes at which to start
// consolidating going forward

var consolidateThreshhold = 10;
var wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);
/**
 * Instantiates the fsevents interface
 * @param {Path} path path to be watched
 * @param {Function} callback called when fsevents is bound and ready
 * @returns {{stop: Function}} new fsevents instance
 */

var createFSEventsInstance = function createFSEventsInstance(path, callback) {
  var stop = fsevents.watch(path, callback);
  return {
    stop: stop
  };
};
/**
 * Instantiates the fsevents interface or binds listeners to an existing one covering
 * the same file tree.
 * @param {Path} path           - to be watched
 * @param {Path} realPath       - real path for symlinks
 * @param {Function} listener   - called when fsevents emits events
 * @param {Function} rawEmitter - passes data to listeners of the 'raw' event
 * @returns {Function} closer
 */


function setFSEventsListener(path, realPath, listener, rawEmitter) {
  var watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;
  var parentPath = sysPath$1.dirname(watchPath);
  var cont = FSEventsWatchers.get(watchPath); // If we've accumulated a substantial number of paths that
  // could have been consolidated by watching one directory
  // above the current one, create a watcher on the parent
  // path instead, so that we do consolidate going forward.

  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }

  var resolvedPath = sysPath$1.resolve(path);
  var hasSymlink = resolvedPath !== realPath;

  var filteredListener = function filteredListener(fullPath, flags, info) {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep)) listener(fullPath, flags, info);
  }; // check if there is already a watcher on a parent path
  // modifies `watchPath` to the parent path when it finds a match


  var watchedParent = false;
  var _iteratorNormalCompletion10 = true;
  var _didIteratorError10 = false;
  var _iteratorError10 = undefined;

  try {
    for (var _iterator10 = FSEventsWatchers.keys()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
      var watchedPath = _step10.value;

      if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {
        watchPath = watchedPath;
        cont = FSEventsWatchers.get(watchPath);
        watchedParent = true;
        break;
      }
    }
  } catch (err) {
    _didIteratorError10 = true;
    _iteratorError10 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
        _iterator10["return"]();
      }
    } finally {
      if (_didIteratorError10) {
        throw _iteratorError10;
      }
    }
  }

  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: new Set([filteredListener]),
      rawEmitter: rawEmitter,
      watcher: createFSEventsInstance(watchPath, function (fullPath, flags) {
        if (!cont.listeners.size) return;
        var info = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach(function (list) {
          list(fullPath, flags, info);
        });
        cont.rawEmitter(info.event, fullPath, info);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  } // removes this instance's listeners and closes the underlying fsevents
  // instance if there are no more listeners left


  return function () {
    var lst = cont.listeners;
    lst["delete"](filteredListener);

    if (!lst.size) {
      FSEventsWatchers["delete"](watchPath);
      if (cont.watcher) return cont.watcher.stop().then(function () {
        cont.rawEmitter = cont.watcher = undefined;
        Object.freeze(cont);
      });
    }
  };
} // Decide whether or not we should start a new higher-level
// parent watcher


var couldConsolidate = function couldConsolidate(path) {
  var count = 0;
  var _iteratorNormalCompletion11 = true;
  var _didIteratorError11 = false;
  var _iteratorError11 = undefined;

  try {
    for (var _iterator11 = FSEventsWatchers.keys()[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
      var watchPath = _step11.value;

      if (watchPath.indexOf(path) === 0) {
        count++;

        if (count >= consolidateThreshhold) {
          return true;
        }
      }
    }
  } catch (err) {
    _didIteratorError11 = true;
    _iteratorError11 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
        _iterator11["return"]();
      }
    } finally {
      if (_didIteratorError11) {
        throw _iteratorError11;
      }
    }
  }

  return false;
}; // returns boolean indicating whether fsevents can be used


var canUse = function canUse() {
  return fsevents && FSEventsWatchers.size < 128;
}; // determines subdirectory traversal levels from root to path


var calcDepth = function calcDepth(path, root) {
  var i = 0;

  while (!path.indexOf(root) && (path = sysPath$1.dirname(path)) !== root) {
    i++;
  }

  return i;
}; // returns boolean indicating whether the fsevents' event info has the same type
// as the one returned by fs.stat


var sameTypes = function sameTypes(info, stats) {
  return info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
};
/**
 * @mixin
 */


var FsEventsHandler$1 =
/*#__PURE__*/
function () {
  /**
   * @param {import('../index').FSWatcher} fsw
   */
  function FsEventsHandler(fsw) {
    _classCallCheck(this, FsEventsHandler);

    this.fsw = fsw;
  }

  _createClass(FsEventsHandler, [{
    key: "checkIgnored",
    value: function checkIgnored(path, stats) {
      var ipaths = this.fsw._ignoredPaths;

      if (this.fsw._isIgnored(path, stats)) {
        ipaths.add(path);

        if (stats && stats.isDirectory()) {
          ipaths.add(path + ROOT_GLOBSTAR);
        }

        return true;
      }

      ipaths["delete"](path);
      ipaths["delete"](path + ROOT_GLOBSTAR);
    }
  }, {
    key: "addOrChange",
    value: function addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
      var event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;
      this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);
    }
  }, {
    key: "checkExists",
    value: function checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {
      var stats;
      return regeneratorRuntime.async(function checkExists$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.prev = 0;
              _context12.next = 3;
              return regeneratorRuntime.awrap(stat$1(path));

            case 3:
              stats = _context12.sent;

              if (!this.fsw.closed) {
                _context12.next = 6;
                break;
              }

              return _context12.abrupt("return");

            case 6:
              if (sameTypes(info, stats)) {
                this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);
              }

              _context12.next = 12;
              break;

            case 9:
              _context12.prev = 9;
              _context12.t0 = _context12["catch"](0);

              if (_context12.t0.code === 'EACCES') {
                this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);
              }

            case 12:
            case "end":
              return _context12.stop();
          }
        }
      }, null, this, [[0, 9]]);
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {
      if (this.fsw.closed || this.checkIgnored(path)) return;

      if (event === EV_UNLINK$1) {
        var isDirectory = info.type === FSEVENT_TYPE_DIRECTORY; // suppress unlink events on never before seen files

        if (isDirectory || watchedDir.has(item)) {
          this.fsw._remove(parent, item, isDirectory);
        }
      } else {
        if (event === EV_ADD$1) {
          // track new directories
          if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);

          if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
            // push symlinks back to the top of the stack to get handled
            var curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;
            return this._addToFsEvents(path, false, true, curDepth);
          } // track new paths
          // (other than symlinks being followed, which will be tracked soon)


          this.fsw._getWatchedDir(parent).add(item);
        }
        /**
         * @type {'add'|'addDir'|'unlink'|'unlinkDir'}
         */


        var eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;

        this.fsw._emit(eventName, path);

        if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path, false, true);
      }
    }
    /**
     * Handle symlinks encountered during directory scan
     * @param {String} watchPath  - file/dir path to be watched with fsevents
     * @param {String} realPath   - real path (in case of symlinks)
     * @param {Function} transform  - path transformer
     * @param {Function} globFilter - path filter in case a glob pattern was provided
     * @returns {Function} closer for the watcher instance
    */

  }, {
    key: "_watchWithFsEvents",
    value: function _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
      var _this6 = this;

      if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
      var opts = this.fsw.options;

      var watchCallback = function watchCallback(fullPath, flags, info) {
        var path, parent, item, watchedDir, stats;
        return regeneratorRuntime.async(function watchCallback$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!_this6.fsw.closed) {
                  _context13.next = 2;
                  break;
                }

                return _context13.abrupt("return");

              case 2:
                if (!(opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth)) {
                  _context13.next = 4;
                  break;
                }

                return _context13.abrupt("return");

              case 4:
                path = transform(sysPath$1.join(watchPath, sysPath$1.relative(watchPath, fullPath)));

                if (!(globFilter && !globFilter(path))) {
                  _context13.next = 7;
                  break;
                }

                return _context13.abrupt("return");

              case 7:
                // ensure directories are tracked
                parent = sysPath$1.dirname(path);
                item = sysPath$1.basename(path);
                watchedDir = _this6.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent); // correct for wrong events emitted

                if (!(wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN)) {
                  _context13.next = 30;
                  break;
                }

                if (!(_typeof(opts.ignored) === FUNCTION_TYPE$1)) {
                  _context13.next = 27;
                  break;
                }

                _context13.prev = 12;
                _context13.next = 15;
                return regeneratorRuntime.awrap(stat$1(path));

              case 15:
                stats = _context13.sent;
                _context13.next = 20;
                break;

              case 18:
                _context13.prev = 18;
                _context13.t0 = _context13["catch"](12);

              case 20:
                if (!_this6.fsw.closed) {
                  _context13.next = 22;
                  break;
                }

                return _context13.abrupt("return");

              case 22:
                if (!_this6.checkIgnored(path, stats)) {
                  _context13.next = 24;
                  break;
                }

                return _context13.abrupt("return");

              case 24:
                if (sameTypes(info, stats)) {
                  _this6.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);
                } else {
                  _this6.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);
                }

                _context13.next = 28;
                break;

              case 27:
                _this6.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);

              case 28:
                _context13.next = 35;
                break;

              case 30:
                _context13.t1 = info.event;
                _context13.next = _context13.t1 === FSEVENT_CREATED ? 33 : _context13.t1 === FSEVENT_MODIFIED ? 33 : _context13.t1 === FSEVENT_DELETED ? 34 : _context13.t1 === FSEVENT_MOVED ? 34 : 35;
                break;

              case 33:
                return _context13.abrupt("return", _this6.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts));

              case 34:
                return _context13.abrupt("return", _this6.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts));

              case 35:
              case "end":
                return _context13.stop();
            }
          }
        }, null, null, [[12, 18]]);
      };

      var closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);

      this.fsw._emitReady();

      return closer;
    }
    /**
     * Handle symlinks encountered during directory scan
     * @param {String} linkPath path to symlink
     * @param {String} fullPath absolute path to the symlink
     * @param {Function} transform pre-existing path transformer
     * @param {Number} curDepth level of subdirectories traversed to where symlink is
     * @returns {Promise<void>}
     */

  }, {
    key: "_handleFsEventsSymlink",
    value: function _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
      var linkTarget;
      return regeneratorRuntime.async(function _handleFsEventsSymlink$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              if (!(this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))) {
                _context14.next = 2;
                break;
              }

              return _context14.abrupt("return");

            case 2:
              this.fsw._symlinkPaths.set(fullPath, true);

              this.fsw._incrReadyCount();

              _context14.prev = 4;
              _context14.next = 7;
              return regeneratorRuntime.awrap(realpath(linkPath));

            case 7:
              linkTarget = _context14.sent;

              if (!this.fsw.closed) {
                _context14.next = 10;
                break;
              }

              return _context14.abrupt("return");

            case 10:
              if (!this.fsw._isIgnored(linkTarget)) {
                _context14.next = 12;
                break;
              }

              return _context14.abrupt("return", this.fsw._emitReady());

            case 12:
              this.fsw._incrReadyCount(); // add the linkTarget for watching with a wrapper for transform
              // that causes emitted paths to incorporate the link's path


              this._addToFsEvents(linkTarget || linkPath, function (path) {
                var aliasedPath = linkPath;

                if (linkTarget && linkTarget !== DOT_SLASH) {
                  aliasedPath = path.replace(linkTarget, linkPath);
                } else if (path !== DOT_SLASH) {
                  aliasedPath = sysPath$1.join(linkPath, path);
                }

                return transform(aliasedPath);
              }, false, curDepth);

              _context14.next = 20;
              break;

            case 16:
              _context14.prev = 16;
              _context14.t0 = _context14["catch"](4);

              if (!this.fsw._handleError(_context14.t0)) {
                _context14.next = 20;
                break;
              }

              return _context14.abrupt("return", this.fsw._emitReady());

            case 20:
            case "end":
              return _context14.stop();
          }
        }
      }, null, this, [[4, 16]]);
    }
    /**
     *
     * @param {Path} newPath
     * @param {fs.Stats} stats
     */

  }, {
    key: "emitAdd",
    value: function emitAdd(newPath, stats, processPath, opts, forceAdd) {
      var pp = processPath(newPath);
      var isDir = stats.isDirectory();

      var dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));

      var base = sysPath$1.basename(pp); // ensure empty dirs get tracked

      if (isDir) this.fsw._getWatchedDir(pp);
      if (dirObj.has(base)) return;
      dirObj.add(base);

      if (!opts.ignoreInitial || forceAdd === true) {
        this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);
      }
    }
  }, {
    key: "initWatch",
    value: function initWatch(realPath, path, wh, processPath) {
      if (this.fsw.closed) return;

      var closer = this._watchWithFsEvents(wh.watchPath, sysPath$1.resolve(realPath || wh.watchPath), processPath, wh.globFilter);

      this.fsw._addPathCloser(path, closer);
    }
    /**
     * Handle added path with fsevents
     * @param {String} path file/dir path or glob pattern
     * @param {Function|Boolean=} transform converts working path to what the user expects
     * @param {Boolean=} forceAdd ensure add is emitted
     * @param {Number=} priorDepth Level of subdirectories already traversed.
     * @returns {Promise<void>}
     */

  }, {
    key: "_addToFsEvents",
    value: function _addToFsEvents(path, transform, forceAdd, priorDepth) {
      var _this7 = this;

      var opts, processPath, wh, stats, realPath;
      return regeneratorRuntime.async(function _addToFsEvents$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              if (!this.fsw.closed) {
                _context15.next = 2;
                break;
              }

              return _context15.abrupt("return");

            case 2:
              opts = this.fsw.options;
              processPath = _typeof(transform) === FUNCTION_TYPE$1 ? transform : IDENTITY_FN;
              wh = this.fsw._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch

              _context15.prev = 5;
              _context15.next = 8;
              return regeneratorRuntime.awrap(statMethods[wh.statMethod](wh.watchPath));

            case 8:
              stats = _context15.sent;

              if (!this.fsw.closed) {
                _context15.next = 11;
                break;
              }

              return _context15.abrupt("return");

            case 11:
              if (!this.fsw._isIgnored(wh.watchPath, stats)) {
                _context15.next = 13;
                break;
              }

              throw null;

            case 13:
              if (!stats.isDirectory()) {
                _context15.next = 20;
                break;
              }

              // emit addDir unless this is a glob parent
              if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd); // don't recurse further if it would exceed depth setting

              if (!(priorDepth && priorDepth > opts.depth)) {
                _context15.next = 17;
                break;
              }

              return _context15.abrupt("return");

            case 17:
              // scan the contents of the dir
              this.fsw._readdirp(wh.watchPath, _objectSpread({
                fileFilter: function fileFilter(entry) {
                  return wh.filterPath(entry);
                },
                directoryFilter: function directoryFilter(entry) {
                  return wh.filterDir(entry);
                }
              }, Depth(opts.depth - (priorDepth || 0)))).on(STR_DATA, function (entry) {
                // need to check filterPath on dirs b/c filterDir is less restrictive
                if (_this7.fsw.closed) {
                  return;
                }

                if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;
                var joinedPath = sysPath$1.join(wh.watchPath, entry.path);
                var fullPath = entry.fullPath;

                if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                  // preserve the current depth here since it can't be derived from
                  // real paths past the symlink
                  var curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;

                  _this7._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
                } else {
                  _this7.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
                }
              }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, function () {
                _this7.fsw._emitReady();
              });

              _context15.next = 22;
              break;

            case 20:
              this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);

              this.fsw._emitReady();

            case 22:
              _context15.next = 27;
              break;

            case 24:
              _context15.prev = 24;
              _context15.t0 = _context15["catch"](5);

              if (!_context15.t0 || this.fsw._handleError(_context15.t0)) {
                // TODO: Strange thing: "should not choke on an ignored watch path" will be failed without 2 ready calls -__-
                this.fsw._emitReady();

                this.fsw._emitReady();
              }

            case 27:
              if (!(opts.persistent && forceAdd !== true)) {
                _context15.next = 41;
                break;
              }

              if (!(_typeof(transform) === FUNCTION_TYPE$1)) {
                _context15.next = 32;
                break;
              }

              // realpath has already been resolved
              this.initWatch(undefined, path, wh, processPath);
              _context15.next = 41;
              break;

            case 32:
              _context15.prev = 32;
              _context15.next = 35;
              return regeneratorRuntime.awrap(realpath(wh.watchPath));

            case 35:
              realPath = _context15.sent;
              _context15.next = 40;
              break;

            case 38:
              _context15.prev = 38;
              _context15.t1 = _context15["catch"](32);

            case 40:
              this.initWatch(realPath, path, wh, processPath);

            case 41:
            case "end":
              return _context15.stop();
          }
        }
      }, null, this, [[5, 24], [32, 38]]);
    }
  }]);

  return FsEventsHandler;
}();

fseventsHandler.exports = FsEventsHandler$1;
fseventsHandler.exports.canUse = canUse;
var fseventsHandlerExports = fseventsHandler.exports;
var EventEmitter = require$$0$3.EventEmitter;
var fs = require$$0$1;
var sysPath = require$$0$2;
var promisify = require$$2.promisify;
var readdirp = readdirp_1;
var anymatch = anymatchExports["default"];
var globParent = globParent$1;
var isGlob = isGlob$2;
var braces = braces_1;
var normalizePath = normalizePath$2;
var NodeFsHandler = nodefsHandler;
var FsEventsHandler = fseventsHandlerExports;
var EV_ALL = constants.EV_ALL,
    EV_READY = constants.EV_READY,
    EV_ADD = constants.EV_ADD,
    EV_CHANGE = constants.EV_CHANGE,
    EV_UNLINK = constants.EV_UNLINK,
    EV_ADD_DIR = constants.EV_ADD_DIR,
    EV_UNLINK_DIR = constants.EV_UNLINK_DIR,
    EV_RAW = constants.EV_RAW,
    EV_ERROR = constants.EV_ERROR,
    STR_CLOSE = constants.STR_CLOSE,
    STR_END = constants.STR_END,
    BACK_SLASH_RE = constants.BACK_SLASH_RE,
    DOUBLE_SLASH_RE = constants.DOUBLE_SLASH_RE,
    SLASH_OR_BACK_SLASH_RE = constants.SLASH_OR_BACK_SLASH_RE,
    DOT_RE = constants.DOT_RE,
    REPLACER_RE = constants.REPLACER_RE,
    SLASH = constants.SLASH,
    SLASH_SLASH = constants.SLASH_SLASH,
    BRACE_START = constants.BRACE_START,
    BANG = constants.BANG,
    ONE_DOT = constants.ONE_DOT,
    TWO_DOTS = constants.TWO_DOTS,
    GLOBSTAR = constants.GLOBSTAR,
    SLASH_GLOBSTAR = constants.SLASH_GLOBSTAR,
    ANYMATCH_OPTS = constants.ANYMATCH_OPTS,
    STRING_TYPE = constants.STRING_TYPE,
    FUNCTION_TYPE = constants.FUNCTION_TYPE,
    EMPTY_STR = constants.EMPTY_STR,
    EMPTY_FN = constants.EMPTY_FN,
    isWindows = constants.isWindows,
    isMacos = constants.isMacos,
    isIBMi = constants.isIBMi;
var stat = promisify(fs.stat);
var readdir = promisify(fs.readdir);
/**
 * @typedef {String} Path
 * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName
 * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType
 */

/**
 *
 * @typedef {Object} WatchHelpers
 * @property {Boolean} followSymlinks
 * @property {'stat'|'lstat'} statMethod
 * @property {Path} path
 * @property {Path} watchPath
 * @property {Function} entryPath
 * @property {Boolean} hasGlob
 * @property {Object} globFilter
 * @property {Function} filterPath
 * @property {Function} filterDir
 */

var arrify = function arrify() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return Array.isArray(value) ? value : [value];
};

var flatten = function flatten(list) {
  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  list.forEach(function (item) {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
};

var unifyPaths = function unifyPaths(paths_) {
  /**
   * @type {Array<String>}
   */
  var paths = flatten(arrify(paths_));

  if (!paths.every(function (p) {
    return _typeof(p) === STRING_TYPE;
  })) {
    throw new TypeError("Non-string provided as watch path: ".concat(paths));
  }

  return paths.map(normalizePathToUnix);
}; // If SLASH_SLASH occurs at the beginning of path, it is not replaced
//     because "//StoragePC/DrivePool/Movies" is a valid network path


var toUnix = function toUnix(string) {
  var str = string.replace(BACK_SLASH_RE, SLASH);
  var prepend = false;

  if (str.startsWith(SLASH_SLASH)) {
    prepend = true;
  }

  while (str.match(DOUBLE_SLASH_RE)) {
    str = str.replace(DOUBLE_SLASH_RE, SLASH);
  }

  if (prepend) {
    str = SLASH + str;
  }

  return str;
}; // Our version of upath.normalize
// TODO: this is not equal to path-normalize module - investigate why


var normalizePathToUnix = function normalizePathToUnix(path) {
  return toUnix(sysPath.normalize(toUnix(path)));
};

var normalizeIgnored = function normalizeIgnored() {
  var cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_STR;
  return function (path) {
    if (_typeof(path) !== STRING_TYPE) return path;
    return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));
  };
};

var getAbsolutePath = function getAbsolutePath(path, cwd) {
  if (sysPath.isAbsolute(path)) {
    return path;
  }

  if (path.startsWith(BANG)) {
    return BANG + sysPath.join(cwd, path.slice(1));
  }

  return sysPath.join(cwd, path);
};

var undef = function undef(opts, key) {
  return opts[key] === undefined;
};
/**
 * Directory entry.
 * @property {Path} path
 * @property {Set<Path>} items
 */


var DirEntry =
/*#__PURE__*/
function () {
  /**
   * @param {Path} dir
   * @param {Function} removeWatcher
   */
  function DirEntry(dir, removeWatcher) {
    _classCallCheck(this, DirEntry);

    this.path = dir;
    this._removeWatcher = removeWatcher;
    /** @type {Set<Path>} */

    this.items = new Set();
  }

  _createClass(DirEntry, [{
    key: "add",
    value: function add(item) {
      var items = this.items;
      if (!items) return;
      if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
    }
  }, {
    key: "remove",
    value: function remove(item) {
      var items, dir;
      return regeneratorRuntime.async(function remove$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              items = this.items;

              if (items) {
                _context16.next = 3;
                break;
              }

              return _context16.abrupt("return");

            case 3:
              items["delete"](item);

              if (!(items.size > 0)) {
                _context16.next = 6;
                break;
              }

              return _context16.abrupt("return");

            case 6:
              dir = this.path;
              _context16.prev = 7;
              _context16.next = 10;
              return regeneratorRuntime.awrap(readdir(dir));

            case 10:
              _context16.next = 15;
              break;

            case 12:
              _context16.prev = 12;
              _context16.t0 = _context16["catch"](7);

              if (this._removeWatcher) {
                this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
              }

            case 15:
            case "end":
              return _context16.stop();
          }
        }
      }, null, this, [[7, 12]]);
    }
  }, {
    key: "has",
    value: function has(item) {
      var items = this.items;
      if (!items) return;
      return items.has(item);
    }
    /**
     * @returns {Array<String>}
     */

  }, {
    key: "getChildren",
    value: function getChildren() {
      var items = this.items;
      if (!items) return;
      return _toConsumableArray(items.values());
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.items.clear();
      delete this.path;
      delete this._removeWatcher;
      delete this.items;
      Object.freeze(this);
    }
  }]);

  return DirEntry;
}();

var STAT_METHOD_F = 'stat';
var STAT_METHOD_L = 'lstat';

var WatchHelper =
/*#__PURE__*/
function () {
  function WatchHelper(path, watchPath, follow, fsw) {
    _classCallCheck(this, WatchHelper);

    this.fsw = fsw;
    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);
    this.watchPath = watchPath;
    this.fullWatchPath = sysPath.resolve(watchPath);
    this.hasGlob = watchPath !== path;
    /** @type {object|boolean} */

    if (path === EMPTY_STR) this.hasGlob = false;
    this.globSymlink = this.hasGlob && follow ? undefined : false;
    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;
    this.dirParts = this.getDirParts(path);
    this.dirParts.forEach(function (parts) {
      if (parts.length > 1) parts.pop();
    });
    this.followSymlinks = follow;
    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
  }

  _createClass(WatchHelper, [{
    key: "checkGlobSymlink",
    value: function checkGlobSymlink(entry) {
      // only need to resolve once
      // first entry should always have entry.parentDir === EMPTY_STR
      if (this.globSymlink === undefined) {
        this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {
          realPath: entry.fullParentDir,
          linkPath: this.fullWatchPath
        };
      }

      if (this.globSymlink) {
        return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
      }

      return entry.fullPath;
    }
  }, {
    key: "entryPath",
    value: function entryPath(entry) {
      return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));
    }
  }, {
    key: "filterPath",
    value: function filterPath(entry) {
      var stats = entry.stats;
      if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
      var resolvedPath = this.entryPath(entry);
      var matchesGlob = this.hasGlob && _typeof(this.globFilter) === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
      return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
    }
  }, {
    key: "getDirParts",
    value: function getDirParts(path) {
      var _this8 = this;

      if (!this.hasGlob) return [];
      var parts = [];
      var expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];
      expandedPath.forEach(function (path) {
        parts.push(sysPath.relative(_this8.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));
      });
      return parts;
    }
  }, {
    key: "filterDir",
    value: function filterDir(entry) {
      if (this.hasGlob) {
        var entryParts = this.getDirParts(this.checkGlobSymlink(entry));
        var globstar = false;
        this.unmatchedGlob = !this.dirParts.some(function (parts) {
          return parts.every(function (part, i) {
            if (part === GLOBSTAR) globstar = true;
            return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
          });
        });
      }

      return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
    }
  }]);

  return WatchHelper;
}();
/**
 * Watches files & directories for changes. Emitted events:
 * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
 *
 *     new FSWatcher()
 *       .add(directories)
 *       .on('add', path => log('File', path, 'was added'))
 */


var FSWatcher =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(FSWatcher, _EventEmitter);

  // Not indenting methods for history sake; for now.
  function FSWatcher(_opts) {
    var _this9;

    _classCallCheck(this, FSWatcher);

    _this9 = _possibleConstructorReturn(this, _getPrototypeOf(FSWatcher).call(this));
    var opts = {};
    if (_opts) Object.assign(opts, _opts); // for frozen objects

    /** @type {Map<String, DirEntry>} */

    _this9._watched = new Map();
    /** @type {Map<String, Array>} */

    _this9._closers = new Map();
    /** @type {Set<String>} */

    _this9._ignoredPaths = new Set();
    /** @type {Map<ThrottleType, Map>} */

    _this9._throttled = new Map();
    /** @type {Map<Path, String|Boolean>} */

    _this9._symlinkPaths = new Map();
    _this9._streams = new Set();
    _this9.closed = false; // Set up default options.

    if (undef(opts, 'persistent')) opts.persistent = true;
    if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;
    if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;
    if (undef(opts, 'interval')) opts.interval = 100;
    if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;
    if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;
    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval; // Enable fsevents on OS X when polling isn't explicitly enabled.

    if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling; // If we can't use fsevents, ensure the options reflect it's disabled.

    var canUseFsEvents = FsEventsHandler.canUse();
    if (!canUseFsEvents) opts.useFsEvents = false; // Use polling on Mac if not using fsevents.
    // Other platforms use non-polling fs_watch.

    if (undef(opts, 'usePolling') && !opts.useFsEvents) {
      opts.usePolling = isMacos;
    } // Always default to polling on IBM i because fs.watch() is not available on IBM i.


    if (isIBMi) {
      opts.usePolling = true;
    } // Global override (useful for end-developers that need to force polling for all
    // instances of chokidar, regardless of usage/dependency depth)


    var envPoll = process.env.CHOKIDAR_USEPOLLING;

    if (envPoll !== undefined) {
      var envLower = envPoll.toLowerCase();

      if (envLower === 'false' || envLower === '0') {
        opts.usePolling = false;
      } else if (envLower === 'true' || envLower === '1') {
        opts.usePolling = true;
      } else {
        opts.usePolling = !!envLower;
      }
    }

    var envInterval = process.env.CHOKIDAR_INTERVAL;

    if (envInterval) {
      opts.interval = Number.parseInt(envInterval, 10);
    } // Editor atomic write normalization enabled by default with fs.watch


    if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
    if (opts.atomic) _this9._pendingUnlinks = new Map();
    if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;
    if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;
    if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
    var awf = opts.awaitWriteFinish;

    if (awf) {
      if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
      if (!awf.pollInterval) awf.pollInterval = 100;
      _this9._pendingWrites = new Map();
    }

    if (opts.ignored) opts.ignored = arrify(opts.ignored);
    var readyCalls = 0;

    _this9._emitReady = function () {
      readyCalls++;

      if (readyCalls >= _this9._readyCount) {
        _this9._emitReady = EMPTY_FN;
        _this9._readyEmitted = true; // use process.nextTick to allow time for listener to be bound

        process.nextTick(function () {
          return _this9.emit(EV_READY);
        });
      }
    };

    _this9._emitRaw = function () {
      var _this10;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return (_this10 = _this9).emit.apply(_this10, [EV_RAW].concat(args));
    };

    _this9._readyEmitted = false;
    _this9.options = opts; // Initialize with proper watcher.

    if (opts.useFsEvents) {
      _this9._fsEventsHandler = new FsEventsHandler(_assertThisInitialized(_this9));
    } else {
      _this9._nodeFsHandler = new NodeFsHandler(_assertThisInitialized(_this9));
    } // You’re frozen when your heart’s not open.


    Object.freeze(opts);
    return _this9;
  } // Public methods

  /**
   * Adds paths to be watched on an existing FSWatcher instance
   * @param {Path|Array<Path>} paths_
   * @param {String=} _origAdd private; for handling non-existent paths to be watched
   * @param {Boolean=} _internal private; indicates a non-user add
   * @returns {FSWatcher} for chaining
   */


  _createClass(FSWatcher, [{
    key: "add",
    value: function add(paths_, _origAdd, _internal) {
      var _this11 = this;

      var _this$options = this.options,
          cwd = _this$options.cwd,
          disableGlobbing = _this$options.disableGlobbing;
      this.closed = false;
      var paths = unifyPaths(paths_);

      if (cwd) {
        paths = paths.map(function (path) {
          var absPath = getAbsolutePath(path, cwd); // Check `path` instead of `absPath` because the cwd portion can't be a glob

          if (disableGlobbing || !isGlob(path)) {
            return absPath;
          }

          return normalizePath(absPath);
        });
      } // set aside negated glob strings


      paths = paths.filter(function (path) {
        if (path.startsWith(BANG)) {
          _this11._ignoredPaths.add(path.slice(1));

          return false;
        } // if a path is being added that was previously ignored, stop ignoring it


        _this11._ignoredPaths["delete"](path);

        _this11._ignoredPaths["delete"](path + SLASH_GLOBSTAR); // reset the cached userIgnored anymatch fn
        // to make ignoredPaths changes effective


        _this11._userIgnored = undefined;
        return true;
      });

      if (this.options.useFsEvents && this._fsEventsHandler) {
        if (!this._readyCount) this._readyCount = paths.length;
        if (this.options.persistent) this._readyCount *= 2;
        paths.forEach(function (path) {
          return _this11._fsEventsHandler._addToFsEvents(path);
        });
      } else {
        if (!this._readyCount) this._readyCount = 0;
        this._readyCount += paths.length;
        Promise.all(paths.map(function _callee3(path) {
          var res;
          return regeneratorRuntime.async(function _callee3$(_context17) {
            while (1) {
              switch (_context17.prev = _context17.next) {
                case 0:
                  _context17.next = 2;
                  return regeneratorRuntime.awrap(_this11._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd));

                case 2:
                  res = _context17.sent;
                  if (res) _this11._emitReady();
                  return _context17.abrupt("return", res);

                case 5:
                case "end":
                  return _context17.stop();
              }
            }
          });
        })).then(function (results) {
          if (_this11.closed) return;
          results.filter(function (item) {
            return item;
          }).forEach(function (item) {
            _this11.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
          });
        });
      }

      return this;
    }
    /**
     * Close watchers or start ignoring events from specified paths.
     * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
     * @returns {FSWatcher} for chaining
    */

  }, {
    key: "unwatch",
    value: function unwatch(paths_) {
      var _this12 = this;

      if (this.closed) return this;
      var paths = unifyPaths(paths_);
      var cwd = this.options.cwd;
      paths.forEach(function (path) {
        // convert to absolute path unless relative path already matches
        if (!sysPath.isAbsolute(path) && !_this12._closers.has(path)) {
          if (cwd) path = sysPath.join(cwd, path);
          path = sysPath.resolve(path);
        }

        _this12._closePath(path);

        _this12._ignoredPaths.add(path);

        if (_this12._watched.has(path)) {
          _this12._ignoredPaths.add(path + SLASH_GLOBSTAR);
        } // reset the cached userIgnored anymatch fn
        // to make ignoredPaths changes effective


        _this12._userIgnored = undefined;
      });
      return this;
    }
    /**
     * Close watchers and remove all listeners from watched paths.
     * @returns {Promise<void>}.
    */

  }, {
    key: "close",
    value: function close() {
      var _this13 = this;

      if (this.closed) return this._closePromise;
      this.closed = true; // Memory management.

      this.removeAllListeners();
      var closers = [];

      this._closers.forEach(function (closerList) {
        return closerList.forEach(function (closer) {
          var promise = closer();
          if (promise instanceof Promise) closers.push(promise);
        });
      });

      this._streams.forEach(function (stream) {
        return stream.destroy();
      });

      this._userIgnored = undefined;
      this._readyCount = 0;
      this._readyEmitted = false;

      this._watched.forEach(function (dirent) {
        return dirent.dispose();
      });

      ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(function (key) {
        _this13["_".concat(key)].clear();
      });
      this._closePromise = closers.length ? Promise.all(closers).then(function () {
        return undefined;
      }) : Promise.resolve();
      return this._closePromise;
    }
    /**
     * Expose list of watched paths
     * @returns {Object} for chaining
    */

  }, {
    key: "getWatched",
    value: function getWatched() {
      var _this14 = this;

      var watchList = {};

      this._watched.forEach(function (entry, dir) {
        var key = _this14.options.cwd ? sysPath.relative(_this14.options.cwd, dir) : dir;
        watchList[key || ONE_DOT] = entry.getChildren().sort();
      });

      return watchList;
    }
  }, {
    key: "emitWithAll",
    value: function emitWithAll(event, args) {
      this.emit.apply(this, _toConsumableArray(args));
      if (event !== EV_ERROR) this.emit.apply(this, [EV_ALL].concat(_toConsumableArray(args)));
    } // Common helpers
    // --------------

    /**
     * Normalize and emit events.
     * Calling _emit DOES NOT MEAN emit() would be called!
     * @param {EventName} event Type of event
     * @param {Path} path File or directory path
     * @param {*=} val1 arguments to be passed with event
     * @param {*=} val2
     * @param {*=} val3
     * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
     */

  }, {
    key: "_emit",
    value: function _emit(event, path, val1, val2, val3) {
      var _this15 = this;

      var opts, args, awf, pw, awfEmit, isThrottled, fullPath, stats;
      return regeneratorRuntime.async(function _emit$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              if (!this.closed) {
                _context18.next = 2;
                break;
              }

              return _context18.abrupt("return");

            case 2:
              opts = this.options;
              if (isWindows) path = sysPath.normalize(path);
              if (opts.cwd) path = sysPath.relative(opts.cwd, path);
              /** @type Array<any> */

              args = [event, path];
              if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);
              awf = opts.awaitWriteFinish;

              if (!(awf && (pw = this._pendingWrites.get(path)))) {
                _context18.next = 11;
                break;
              }

              pw.lastChange = new Date();
              return _context18.abrupt("return", this);

            case 11:
              if (!opts.atomic) {
                _context18.next = 17;
                break;
              }

              if (!(event === EV_UNLINK)) {
                _context18.next = 16;
                break;
              }

              this._pendingUnlinks.set(path, args);

              setTimeout(function () {
                _this15._pendingUnlinks.forEach(function (entry, path) {
                  _this15.emit.apply(_this15, _toConsumableArray(entry));

                  _this15.emit.apply(_this15, [EV_ALL].concat(_toConsumableArray(entry)));

                  _this15._pendingUnlinks["delete"](path);
                });
              }, typeof opts.atomic === 'number' ? opts.atomic : 100);
              return _context18.abrupt("return", this);

            case 16:
              if (event === EV_ADD && this._pendingUnlinks.has(path)) {
                event = args[0] = EV_CHANGE;

                this._pendingUnlinks["delete"](path);
              }

            case 17:
              if (!(awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted)) {
                _context18.next = 21;
                break;
              }

              awfEmit = function awfEmit(err, stats) {
                if (err) {
                  event = args[0] = EV_ERROR;
                  args[1] = err;

                  _this15.emitWithAll(event, args);
                } else if (stats) {
                  // if stats doesn't exist the file must have been deleted
                  if (args.length > 2) {
                    args[2] = stats;
                  } else {
                    args.push(stats);
                  }

                  _this15.emitWithAll(event, args);
                }
              };

              this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);

              return _context18.abrupt("return", this);

            case 21:
              if (!(event === EV_CHANGE)) {
                _context18.next = 25;
                break;
              }

              isThrottled = !this._throttle(EV_CHANGE, path, 50);

              if (!isThrottled) {
                _context18.next = 25;
                break;
              }

              return _context18.abrupt("return", this);

            case 25:
              if (!(opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE))) {
                _context18.next = 38;
                break;
              }

              fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;
              _context18.prev = 27;
              _context18.next = 30;
              return regeneratorRuntime.awrap(stat(fullPath));

            case 30:
              stats = _context18.sent;
              _context18.next = 35;
              break;

            case 33:
              _context18.prev = 33;
              _context18.t0 = _context18["catch"](27);

            case 35:
              if (!(!stats || this.closed)) {
                _context18.next = 37;
                break;
              }

              return _context18.abrupt("return");

            case 37:
              args.push(stats);

            case 38:
              this.emitWithAll(event, args);
              return _context18.abrupt("return", this);

            case 40:
            case "end":
              return _context18.stop();
          }
        }
      }, null, this, [[27, 33]]);
    }
    /**
     * Common handler for errors
     * @param {Error} error
     * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
     */

  }, {
    key: "_handleError",
    value: function _handleError(error) {
      var code = error && error.code;

      if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {
        this.emit(EV_ERROR, error);
      }

      return error || this.closed;
    }
    /**
     * Helper utility for throttling
     * @param {ThrottleType} actionType type being throttled
     * @param {Path} path being acted upon
     * @param {Number} timeout duration of time to suppress duplicate actions
     * @returns {Object|false} tracking object or false if action should be suppressed
     */

  }, {
    key: "_throttle",
    value: function _throttle(actionType, path, timeout) {
      if (!this._throttled.has(actionType)) {
        this._throttled.set(actionType, new Map());
      }
      /** @type {Map<Path, Object>} */


      var action = this._throttled.get(actionType);
      /** @type {Object} */


      var actionPath = action.get(path);

      if (actionPath) {
        actionPath.count++;
        return false;
      }

      var timeoutObject;

      var clear = function clear() {
        var item = action.get(path);
        var count = item ? item.count : 0;
        action["delete"](path);
        clearTimeout(timeoutObject);
        if (item) clearTimeout(item.timeoutObject);
        return count;
      };

      timeoutObject = setTimeout(clear, timeout);
      var thr = {
        timeoutObject: timeoutObject,
        clear: clear,
        count: 0
      };
      action.set(path, thr);
      return thr;
    }
  }, {
    key: "_incrReadyCount",
    value: function _incrReadyCount() {
      return this._readyCount++;
    }
    /**
     * Awaits write operation to finish.
     * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
     * @param {Path} path being acted upon
     * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
     * @param {EventName} event
     * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
     */

  }, {
    key: "_awaitWriteFinish",
    value: function _awaitWriteFinish(path, threshold, event, awfEmit) {
      var _this16 = this;

      var timeoutHandler;
      var fullPath = path;

      if (this.options.cwd && !sysPath.isAbsolute(path)) {
        fullPath = sysPath.join(this.options.cwd, path);
      }

      var now = new Date();

      var awaitWriteFinish = function awaitWriteFinish(prevStat) {
        fs.stat(fullPath, function (err, curStat) {
          if (err || !_this16._pendingWrites.has(path)) {
            if (err && err.code !== 'ENOENT') awfEmit(err);
            return;
          }

          var now = Number(new Date());

          if (prevStat && curStat.size !== prevStat.size) {
            _this16._pendingWrites.get(path).lastChange = now;
          }

          var pw = _this16._pendingWrites.get(path);

          var df = now - pw.lastChange;

          if (df >= threshold) {
            _this16._pendingWrites["delete"](path);

            awfEmit(undefined, curStat);
          } else {
            timeoutHandler = setTimeout(awaitWriteFinish, _this16.options.awaitWriteFinish.pollInterval, curStat);
          }
        });
      };

      if (!this._pendingWrites.has(path)) {
        this._pendingWrites.set(path, {
          lastChange: now,
          cancelWait: function cancelWait() {
            _this16._pendingWrites["delete"](path);

            clearTimeout(timeoutHandler);
            return event;
          }
        });

        timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);
      }
    }
  }, {
    key: "_getGlobIgnored",
    value: function _getGlobIgnored() {
      return _toConsumableArray(this._ignoredPaths.values());
    }
    /**
     * Determines whether user has asked to ignore this path.
     * @param {Path} path filepath or dir
     * @param {fs.Stats=} stats result of fs.stat
     * @returns {Boolean}
     */

  }, {
    key: "_isIgnored",
    value: function _isIgnored(path, stats) {
      if (this.options.atomic && DOT_RE.test(path)) return true;

      if (!this._userIgnored) {
        var cwd = this.options.cwd;
        var ign = this.options.ignored;
        var ignored = ign && ign.map(normalizeIgnored(cwd));
        var paths = arrify(ignored).filter(function (path) {
          return _typeof(path) === STRING_TYPE && !isGlob(path);
        }).map(function (path) {
          return path + SLASH_GLOBSTAR;
        });

        var list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);

        this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);
      }

      return this._userIgnored([path, stats]);
    }
  }, {
    key: "_isntIgnored",
    value: function _isntIgnored(path, stat) {
      return !this._isIgnored(path, stat);
    }
    /**
     * Provides a set of common helpers and properties relating to symlink and glob handling.
     * @param {Path} path file, directory, or glob pattern being watched
     * @param {Number=} depth at any depth > 0, this isn't a glob
     * @returns {WatchHelper} object containing helpers for this path
     */

  }, {
    key: "_getWatchHelpers",
    value: function _getWatchHelpers(path, depth) {
      var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);
      var follow = this.options.followSymlinks;
      return new WatchHelper(path, watchPath, follow, this);
    } // Directory helpers
    // -----------------

    /**
     * Provides directory tracking objects
     * @param {String} directory path of the directory
     * @returns {DirEntry} the directory's tracking object
     */

  }, {
    key: "_getWatchedDir",
    value: function _getWatchedDir(directory) {
      if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
      var dir = sysPath.resolve(directory);
      if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
      return this._watched.get(dir);
    } // File helpers
    // ------------

    /**
     * Check for read permissions.
     * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
     * @param {fs.Stats} stats - object, result of fs_stat
     * @returns {Boolean} indicates whether the file can be read
    */

  }, {
    key: "_hasReadPermissions",
    value: function _hasReadPermissions(stats) {
      if (this.options.ignorePermissionErrors) return true; // stats.mode may be bigint

      var md = stats && Number.parseInt(stats.mode, 10);
      var st = md & 511;
      var it = Number.parseInt(st.toString(8)[0], 10);
      return Boolean(4 & it);
    }
    /**
     * Handles emitting unlink events for
     * files and directories, and via recursion, for
     * files and directories within directories that are unlinked
     * @param {String} directory within which the following item is located
     * @param {String} item      base path of item/directory
     * @returns {void}
    */

  }, {
    key: "_remove",
    value: function _remove(directory, item, isDirectory) {
      var _this17 = this;

      // if what is being deleted is a directory, get that directory's paths
      // for recursive deleting and cleaning of watched object
      // if it is not a directory, nestedDirectoryChildren will be empty array
      var path = sysPath.join(directory, item);
      var fullPath = sysPath.resolve(path);
      isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath); // prevent duplicate handling in case of arriving here nearly simultaneously
      // via multiple paths (such as _handleFile and _handleDir)

      if (!this._throttle('remove', path, 100)) return; // if the only watched file is removed, watch for its return

      if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
        this.add(directory, item, true);
      } // This will create a new entry in the watched object in either case
      // so we got to do the directory check beforehand


      var wp = this._getWatchedDir(path);

      var nestedDirectoryChildren = wp.getChildren(); // Recursively remove children directories / files.

      nestedDirectoryChildren.forEach(function (nested) {
        return _this17._remove(path, nested);
      }); // Check if item was on the watched list and remove it

      var parent = this._getWatchedDir(directory);

      var wasTracked = parent.has(item);
      parent.remove(item); // Fixes issue #1042 -> Relative paths were detected and added as symlinks
      // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),
      // but never removed from the map in case the path was deleted.
      // This leads to an incorrect state if the path was recreated:
      // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553

      if (this._symlinkPaths.has(fullPath)) {
        this._symlinkPaths["delete"](fullPath);
      } // If we wait for this file to be fully written, cancel the wait.


      var relPath = path;
      if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);

      if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
        var event = this._pendingWrites.get(relPath).cancelWait();

        if (event === EV_ADD) return;
      } // The Entry will either be a directory that just got removed
      // or a bogus entry to a file, in either case we have to remove it


      this._watched["delete"](path);

      this._watched["delete"](fullPath);

      var eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
      if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path); // Avoid conflicts if we later create another file with the same name

      if (!this.options.useFsEvents) {
        this._closePath(path);
      }
    }
    /**
     * Closes all watchers for a path
     * @param {Path} path
     */

  }, {
    key: "_closePath",
    value: function _closePath(path) {
      this._closeFile(path);

      var dir = sysPath.dirname(path);

      this._getWatchedDir(dir).remove(sysPath.basename(path));
    }
    /**
     * Closes only file-specific watchers
     * @param {Path} path
     */

  }, {
    key: "_closeFile",
    value: function _closeFile(path) {
      var closers = this._closers.get(path);

      if (!closers) return;
      closers.forEach(function (closer) {
        return closer();
      });

      this._closers["delete"](path);
    }
    /**
     *
     * @param {Path} path
     * @param {Function} closer
     */

  }, {
    key: "_addPathCloser",
    value: function _addPathCloser(path, closer) {
      if (!closer) return;

      var list = this._closers.get(path);

      if (!list) {
        list = [];

        this._closers.set(path, list);
      }

      list.push(closer);
    }
  }, {
    key: "_readdirp",
    value: function _readdirp(root, opts) {
      var _this18 = this;

      if (this.closed) return;

      var options = _objectSpread({
        type: EV_ALL,
        alwaysStat: true,
        lstat: true
      }, opts);

      var stream = readdirp(root, options);

      this._streams.add(stream);

      stream.once(STR_CLOSE, function () {
        stream = undefined;
      });
      stream.once(STR_END, function () {
        if (stream) {
          _this18._streams["delete"](stream);

          stream = undefined;
        }
      });
      return stream;
    }
  }]);

  return FSWatcher;
}(EventEmitter); // Export FSWatcher class


chokidar.FSWatcher = FSWatcher;
/**
 * Instantiates watcher with paths to be tracked.
 * @param {String|Array<String>} paths file/directory paths and/or globs
 * @param {Object=} options chokidar opts
 * @returns an instance of FSWatcher for chaining.
 */

var watch = function watch(paths, options) {
  var watcher = new FSWatcher(options);
  watcher.add(paths);
  return watcher;
};

chokidar.watch = watch;
exports.chokidar = chokidar;